{

module FunWithFlags.FunDB.SQL.Lexer

open System
open Microsoft.FSharp.Text.Lexing

open FunWithFlags.FunDB.Parsing
open FunWithFlags.FunDB.SQL.Parsing

}

// Regular expressions
let whitespace = [' ' '\t' ]
let newline = ('\n' | "\r\n")

// Case-insensitive chars
let a = ['A' 'a']
let b = ['B' 'b']
let c = ['C' 'c']
let d = ['D' 'd']
let e = ['E' 'e']
let f = ['F' 'f']
let g = ['G' 'g']
let h = ['H' 'h']
let i = ['I' 'i']
let j = ['J' 'j']
let k = ['K' 'k']
let l = ['L' 'l']
let m = ['M' 'm']
let n = ['N' 'n']
let o = ['O' 'o']
let p = ['P' 'p']
let q = ['Q' 'q']
let r = ['R' 'r']
let s = ['S' 's']
let t = ['T' 't']
let u = ['U' 'u']
let v = ['V' 'v']
let w = ['W' 'w']
let x = ['X' 'x']
let y = ['Y' 'y']
let z = ['Z' 'z']

rule tokenizeSQL = parse
    // Atoms
    | ['+' '-']? ['0'-'9'] ['0'-'9']* "." ['0'-'9']* { Parser.DECIMAL (lexbuf.Lexeme |> String |> decimal) }
    | ['+' '-']? ['0'-'9'] ['0'-'9']* { Parser.INT (lexbuf.Lexeme |> String |> int) }
    | "\"" ( [^ '"'] | "\"\"" )* "\"" { Parser.QUOTED_ID (escapedId 0 lexbuf) }
    | e "'" ( [^ '\\' '\''] | "\\" _ )* "'" { Parser.STRING (escapedString 1 lexbuf) }
    | "'" ( [^ '\''] | "''" )* "'" { Parser.STRING (sqlString 0 lexbuf) }

    // Symbols
    | "::"  { Parser.DOUBLE_COLON }
    | "("   { Parser.LEFT_PAREN }
    | ")"   { Parser.RIGHT_PAREN }
    | "["   { Parser.LEFT_BRACKET }
    | "]"   { Parser.RIGHT_BRACKET }
    | ","   { Parser.COMMA }
    | "."   { Parser.DOT }
    | "="   { Parser.EQ }
    | "<>"  { Parser.NOT_EQ }
    | "!="  { Parser.NOT_EQ }
    | ">="  { Parser.GREATER_EQ }
    | ">"   { Parser.GREATER }
    | "<="  { Parser.LESS_EQ }
    | "<"   { Parser.LESS }
    | "||"  { Parser.CONCAT }
    | "~~"  { Parser.LIKE_OP }
    | "!~~" { Parser.NOT_LIKE_OP }

    // Keywords
    | t r u e         { Parser.BOOL true }
    | f a l s e       { Parser.BOOL false }
    | n u l l         { Parser.NULL }
    | a n d           { Parser.AND }
    | o r             { Parser.OR }
    | i s             { Parser.IS }
    | n o t           { Parser.NOT }
    | c a s e         { Parser.CASE }
    | w h e n         { Parser.WHEN }
    | t h e n         { Parser.THEN }
    | e l s e         { Parser.ELSE }
    | e n d           { Parser.END }
    | c o a l e s c e { Parser.COALESCE }

    // Unescaped ids
    | ['a'-'z' 'A'-'Z' '_'] ['a'-'z' 'A'-'Z' '0'-'9' '_' '$']* { Parser.ID ((String lexbuf.Lexeme).ToLower()) }

    // Whitespace
    | whitespace { tokenizeSQL lexbuf }
    | newline    { newline lexbuf; tokenizeSQL lexbuf }

    // Misc
    | _    	  { failwith <| sprintf "Parse error: %s" (LexBuffer<_>.LexemeString lexbuf) }
    | eof     { Parser.EOF }
