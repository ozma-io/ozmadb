{

module FunWithFlags.FunDB.FunQL.Lexer

open System
open Microsoft.FSharp.Text.Lexing

open FunWithFlags.FunDB.Utils
open FunWithFlags.FunDB.Parsing.Helpers
open FunWithFlags.FunDB.FunQL

}

// Regular expressions
let whitespace = [' ' '\t' ]
let newline = ('\n' | "\r\n")
let escapes = "\\" ['\\' 't' 'r' 'n']
let string = "'" ([^ '\\' '\''] | "\\'" | escapes)* "'"
let escapedId  = "\"" ([^ '\\' '"'] | "\\\"" | escapes)* "\""
let unescapedId = ['a'-'z' 'A'-'Z' '_'] ['a'-'z' 'A'-'Z' '0'-'9' '_']*

// Case-insensitive chars
let a = ['A' 'a']
let b = ['B' 'b']
let c = ['C' 'c']
let d = ['D' 'd']
let e = ['E' 'e']
let f = ['F' 'f']
let g = ['G' 'g']
let h = ['H' 'h']
let i = ['I' 'i']
let j = ['J' 'j']
let k = ['K' 'k']
let l = ['L' 'l']
let m = ['M' 'm']
let n = ['N' 'n']
let o = ['O' 'o']
let p = ['P' 'p']
let q = ['Q' 'q']
let r = ['R' 'r']
let s = ['S' 's']
let t = ['T' 't']
let u = ['U' 'u']
let v = ['V' 'v']
let w = ['W' 'w']
let x = ['X' 'x']
let y = ['Y' 'y']
let z = ['Z' 'z']

rule commentFunQL level = parse
    | "/*"       { commentFunQL (level + 1) lexbuf }
    | "*/"       { if level = 0 then () else commentFunQL (level - 1) lexbuf }
    | escapedId  { commentFunQL level lexbuf }
    | string     { commentFunQL level lexbuf }
    | newline    { newline lexbuf; commentFunQL level lexbuf }
    | _          { commentFunQL level lexbuf }

and lineCommentFunQL = parse
    | newline { newline lexbuf }
    | _       { lineCommentFunQL lexbuf }

and tokenizeFunQL = parse
    // Atoms
    | ['+' '-']? ['0'-'9'] ['0'-'9']* "." ['0'-'9']* { Parser.DECIMAL (lexbuf.Lexeme |> String |> decimal) }
    | ['+' '-']? ['0'-'9'] ['0'-'9']*                { Parser.INT (lexbuf.Lexeme |> String |> tryIntInvariant |> Option.get) }
    | escapedId                                      { Parser.ID (escapedString '\"' 0 lexbuf) }
    | string                                         { Parser.STRING (escapedString '\'' 0 lexbuf) }

    // Argument IDs
    | "$$" escapedId   { Parser.GLOBAL_ARGUMENT_ID (escapedString '\"' 2 lexbuf) }
    | "$$" unescapedId { Parser.GLOBAL_ARGUMENT_ID ((String lexbuf.Lexeme).Remove(0, 2).ToLower()) }
    | "$" escapedId    { Parser.ARGUMENT_ID (escapedString '\"' 1 lexbuf) }
    | "$" unescapedId  { Parser.ARGUMENT_ID ((String lexbuf.Lexeme).Remove(0, 1).ToLower()) }

    // Symbols
    | "@{" { Parser.AT_LEFT_BRACE }
    | "{"  { Parser.LEFT_BRACE }
    | "}"  { Parser.RIGHT_BRACE }
    | "("  { Parser.LEFT_PAREN }
    | ")"  { Parser.RIGHT_PAREN }
    | "["  { Parser.LEFT_BRACKET }
    | "]"  { Parser.RIGHT_BRACKET }
    | "::" { Parser.DOUBLE_COLON }
    | ","  { Parser.COMMA }
    | "."  { Parser.DOT }
    | "="  { Parser.EQ }
    | "<>" { Parser.NOT_EQ }
    | "!=" { Parser.NOT_EQ }
    | ">=" { Parser.GREATER_EQ }
    | ">"  { Parser.GREATER }
    | "<=" { Parser.LESS_EQ }
    | "<"  { Parser.LESS }
    | "@"  { Parser.AT }
    | "=>" { Parser.ARROW }
    | "||" { Parser.CONCAT }
    | "*"  { Parser.STAR }
    
    // Keywords
    | t r u e           { Parser.BOOL true }
    | f a l s e         { Parser.BOOL false }
    | n u l l           { Parser.NULL }
    | s e l e c t       { Parser.SELECT }
    | f r o m           { Parser.FROM }
    | w h e r e         { Parser.WHERE }
    | l e f t           { Parser.LEFT }
    | r i g h t         { Parser.RIGHT }
    | i n n e r         { Parser.INNER }
    | o u t e r         { Parser.OUTER }
    | j o i n           { Parser.JOIN }
    | o n               { Parser.ON }
    | o r d e r         { Parser.ORDER }
    | b y               { Parser.BY }
    | a s               { Parser.AS }
    | a s c             { Parser.ASC }
    | d e s c           { Parser.DESC }
    | a n d             { Parser.AND }
    | o r               { Parser.OR }
    | l i k e           { Parser.LIKE }
    | i n               { Parser.IN }
    | i s               { Parser.IS }
    | n o t             { Parser.NOT }
    | f o r             { Parser.FOR }
    | i n s e r t       { Parser.INSERT }
    | i n t o           { Parser.INTO }
    | c a s e           { Parser.CASE }
    | w h e n           { Parser.WHEN }
    | t h e n           { Parser.THEN }
    | e l s e           { Parser.ELSE }
    | e n d             { Parser.END }
    | c o a l e s c e   { Parser.COALESCE }
    | l i m i t         { Parser.LIMIT }
    | o f f s e t       { Parser.OFFSET }
    | u n i o n         { Parser.UNION }
    | i n t e r s e c t { Parser.INTERSECT} 
    | u p d a t e       { Parser.UPDATE }
    | o f               { Parser.OF }
                            
    // Types
    | i n t             { Parser.INT_TYPE }
    | d e c i m a l     { Parser.DECIMAL_TYPE }
    | s t r i n g       { Parser.STRING_TYPE }
    | b o o l           { Parser.BOOL_TYPE }
    | d a t e t i m e   { Parser.DATETIME_TYPE }
    | d a t e           { Parser.DATE_TYPE }
    | r e f e r e n c e { Parser.REFERENCE_TYPE }
    | a r r a y         { Parser.ARRAY_TYPE }
    | e n u m           { Parser.ENUM_TYPE }
    
    // Unescaped ids
    | unescapedId { Parser.ID ((String lexbuf.Lexeme).ToLower()) }
    
    // Whitespace
    | whitespace { tokenizeFunQL lexbuf }
    | "--"       { lineCommentFunQL lexbuf; tokenizeFunQL lexbuf }
    | "/*"       { commentFunQL 0 lexbuf; tokenizeFunQL lexbuf }
    | newline    { newline lexbuf; tokenizeFunQL lexbuf }

    // Misc
    | _   { failwith <| sprintf "Lexical error: %s" (LexBuffer<_>.LexemeString lexbuf) }
    | eof { Parser.EOF }
