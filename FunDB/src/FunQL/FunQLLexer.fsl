{

module internal FunWithFlags.FunDB.FunQL.Lexer

open System
open Microsoft.FSharp.Text.Lexing

open FunWithFlags.FunDB.Utils
open FunWithFlags.FunDB.Parsing
open FunWithFlags.FunDB.FunQL

}

// Regular expressions
let whitespace = [' ' '\t' ]
let newline = ('\n' | "\r\n")
let escapes = "\\" ['\\' 't' 'r' 'n']

// Case-insensitive chars
let a = ['A' 'a']
let b = ['B' 'b']
let c = ['C' 'c']
let d = ['D' 'd']
let e = ['E' 'e']
let f = ['F' 'f']
let g = ['G' 'g']
let h = ['H' 'h']
let i = ['I' 'i']
let j = ['J' 'j']
let k = ['K' 'k']
let l = ['L' 'l']
let m = ['M' 'm']
let n = ['N' 'n']
let o = ['O' 'o']
let p = ['P' 'p']
let q = ['Q' 'q']
let r = ['R' 'r']
let s = ['S' 's']
let t = ['T' 't']
let u = ['U' 'u']
let v = ['V' 'v']
let w = ['W' 'w']
let x = ['X' 'x']
let y = ['Y' 'y']
let z = ['Z' 'z']

rule tokenstream = parse

// Atoms
| ['+' '-']? ['0'-'9'] ['0'-'9']* { Parser.INT(lexbuf.Lexeme |> String |> tryIntInvariant |> Option.get) }
// FIXME: Add floats
| "\"" ([^ '\\' '"'] | "\\\"" | escapes)* "\"" { Parser.ID(escapedString '\"' lexbuf) }
| "'" ([^ '\\' '\''] | "\\'" | escapes)* "'" { Parser.STRING(escapedString '\'' lexbuf) }
| "{" { Parser.LEFT_BRACE }
| "}" { Parser.RIGHT_BRACE }
| "[" { Parser.LEFT_BRACKET }
| "]" { Parser.RIGHT_BRACKET }
| "(" { Parser.LEFT_PARENS }
| ")" { Parser.RIGHT_PARENS }
| ";" { Parser.SEMICOLON }
| "::" { Parser.DOUBLE_COLON }
| "," { Parser.COMMA }
| "." { Parser.DOT }
| "=" { Parser.EQ }

// Keywords
| t r u e { Parser.BOOL(true) }
| f a l s e { Parser.BOOL(false) }
| n u l l { Parser.NULL }
| s e l e c t { Parser.SELECT }
| f r o m { Parser.FROM }
| w h e r e { Parser.WHERE }
| l e f t { Parser.LEFT }
| r i g h t { Parser.RIGHT }
| i n n e r { Parser.INNER }
| o u t e r { Parser.OUTER }
| j o i n { Parser.JOIN }
| o n { Parser.ON }
| o r d e r { Parser.ORDER }
| b y { Parser.BY }
| a s { Parser.AS }
| a s c { Parser.ASC }
| d e s c { Parser.DESC }
| a n d { Parser.AND }

// Types
| i n t { Parser.INT_TYPE }
| s t r i n g { Parser.STRING_TYPE }
| b o o l { Parser.BOOL_TYPE }
| d a t e t i m e { Parser.DATETIME_TYPE }
| d a t e { Parser.DATE_TYPE }
| r e f e r e n c e { Parser.REFERENCE_TYPE }
| e n u m { Parser.ENUM_TYPE }

// Unescaped ids
| ['a'-'z' 'A'-'Z'] ['a'-'z' 'A'-'Z' '0'-'9']* { Parser.ID((String lexbuf.Lexeme).ToLower()) }

// Whitespace
| whitespace { tokenstream lexbuf }
| newline    { newline lexbuf; tokenstream lexbuf }

// Misc
| _    	  { failwith ("Parse error: " + LexBuffer<_>.LexemeString lexbuf) }
| eof     { Parser.EOF }
