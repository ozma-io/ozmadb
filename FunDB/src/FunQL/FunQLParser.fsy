%{

open FunWithFlags.FunDB.Utils
open FunWithFlags.FunDB.FunQL.AST

let private applyJoin fromExpr1 (joinType, fromExpr2, whereExpr) =
    FJoin (joinType, fromExpr1, fromExpr2, whereExpr)

type ParsedFieldExpr = FieldExpr<FieldRef>
type ResolvedFromExpr = FromExpr<EntityRef, FieldRef>
type ParsedFromClause = FromClause<EntityRef, FieldRef>
type ParsedQueryExpr = QueryExpr<EntityRef, FieldRef>
type ParsedQueryResult = QueryResult<FieldRef>
type ParsedViewExpr = ViewExpr<FieldRef>
type ParsedAttributeMap = AttributeMap<FieldRef>

type private AttributedResult =
    | AResult of ParsedAttributeMap * Result<FieldRef>
    | AAttribute of FunQLName * Attribute

let private parseMap (error : string) (vals : ('k * 'v) seq) : Map<'k, 'v> =
    try
        mapOfSeqUnique vals
    with
        | Failure msg -> failwith <| sprintf "%s: %s" error msg

let private splitResults (results : AttributedResult seq) : ParsedAttributeMap * ParsedQueryResult =
    let getResult = function
        | AResult (attrs, res) -> Some (attrs, res)
        | AAttribute (name, attr) -> None
    let getAttribute = function
        | AResult (attrs, res) -> None
        | AAttribute (name, attr) -> Some (name, attr)

    let attributes = results |> seqMapMaybe getAttribute |> parseMap "Clashing row attribute names"    
    let results = results |> seqMapMaybe getResult |> Seq.toArray
    (attributes, results)

%}

// Atoms
%token <int> INT
%token <string> ID
%token <string> ARGUMENT_ID
%token <string> STRING
%token <bool> BOOL
%token NULL

// Symbols
%token LEFT_BRACE
%token RIGHT_BRACE
%token LEFT_PAREN
%token RIGHT_PAREN
%token LEFT_BRACKET
%token RIGHT_BRACKET
%token DOUBLE_COLON
%token COMMA
%token DOT
%token EQ
%token NOT_EQ
%token AT
%token LESS
%token GREATER
%token LESS_EQ
%token GREATER_EQ
%token ARROW

// Keywords
%token SELECT
%token FROM
%token WHERE
%token LEFT
%token RIGHT
%token INNER
%token OUTER
%token JOIN
%token ON
%token ORDER
%token BY
%token AS
%token ASC
%token DESC
%token AND
%token OR
%token LIKE
%token IN
%token IS
%token NOT

// Types
%token INT_TYPE
%token STRING_TYPE
%token BOOL_TYPE
%token DATETIME_TYPE
%token DATE_TYPE
%token REFERENCE_TYPE
%token ARRAY_TYPE
%token ENUM_TYPE

// Misc
%token EOF

%left OR
%left AND
%right NOT
%right EQ NOT_EQ
%left LESS GREATER LESS_EQ GREATER_EQ
%nonassoc LIKE
%nonassoc IN
%nonassoc IS
%left DOUBLE_COLON
%left DOT

%start viewExpr
%type <ParsedViewExpr> viewExpr

%start fieldType
%type <ParsedFieldType> fieldType

%start fieldExpr
%type <ParsedFieldExpr> fieldExpr

%%

// Entry points
viewExpr : ViewExpr EOF { $1 }
fieldExpr : FieldExpr EOF { $1 }
fieldType : FieldType EOF { $1 }

// Expressions

ViewExpr:
  | MaybeArguments SELECT AttributedResults FromClause {
      let (attributes, results) = splitResults $3
      { arguments = $1; attributes = attributes; results = results; clause = $4 }
  }

MaybeArguments:
  |                                            { [] }
  | LEFT_PAREN ArgumentsList RIGHT_PAREN ARROW { $2 }

ArgumentsList:
  |                       { Map.empty }
  | ArgumentsListNonEmpty { parseMap "Clashing argument names" $1 }

ArgumentsListNonEmpty:
  | Argument COMMA ArgumentsListNonEmpty { $1 :: $3 }
  | Argument                             { [ $1 ] }

Argument:
  | FieldRef ArgumentFieldType { ($2, $1) }

FromClause:
  | FROM FromExpr WhereClause OrderByClause { { from = $2; where = $3; orderBy = $4 } }

Query:
	| SELECT Results FromClause { { results = $2; clause = $3 } }

Results:
  |                 { [||] }
  | ResultsNonEmpty { List.toArray $1 }

ResultsNonEmpty:
  | Result COMMA ResultsNonEmpty { $1 :: $3 }
  | Result                       { [ $1 ] }

AttributedResults:
  |                           { [] }
  | AttributedResultsNonEmpty { $1 }

AttributedResultsNonEmpty:
  | AttributedResult COMMA AttributedResultsNonEmpty { $1 :: $3 }
  | AttributedResult                                 { [ $1 ] }

AttributedResult:
  | MaybeAttributeMap Result { AResult ($1, $2) }
  | AT ID EQ FieldExpr       { AAttribute ($2, $4) }

MaybeAttributeMap:
  |                                                { Map.empty }
  | LEFT_BRACE RIGHT_BRACE                         { Map.empty }
  | LEFT_BRACE AttributeValuesNonEmpty RIGHT_BRACE { parseMap "Clashing attribute names" $2 }

AttributeValuesNonEmpty:
  | ID EQ FieldExpr                               { [($1, $3)] }
  | ID EQ FieldExpr COMMA AttributeValuesNonEmpty { ($1, $3) :: $5 }

Result:
  | FieldRef        { { name = $1.name; expr = FEColumn $1 } }
  | FieldExpr AS ID { { name = $3; expr = $1 } }

QuerySource:
  | LEFT_PAREN Query RIGHT_PAREN AS ID { FSubExpr ($5, $2) }
  | EntityRef                          { FEntity ($1) }

JoinType:
  |       { Inner }
  | INNER { Inner }
  | OUTER { Outer }
  | LEFT  { Left  }
  | RIGHT { Right }

JoinChain:
  | { [] }
  | JoinType JOIN QuerySource ON FieldExpr JoinChain { ($1, $3, $5) :: $6 }

FromExpr:
  | QuerySource JoinChain { List.fold applyJoin $1 $2 }

EntityRef:
  | ID DOT ID { { schema = Some (FunQLName $1); name = FunQLName $3; } }
  | ID        { { schema = None; name = $1; } }

FieldRef:
  | ID DOT ID DOT ID { { entity = Some { schema = Some (FunQLName $1); name = FunQLName $3 }; name = FunQLName $5 } }
  | ID DOT ID        { { entity = Some { schema = None; name = FunQLName $1 }; name = FunQLName $3 } }
  | ID               { { entity = None; name = FunQLName $1 } }

WhereClause:
  |                 { None }
  | WHERE FieldExpr { Some $2 }

InList:
  | FieldExpr              { [ $1 ] }
  | FieldExpr COMMA InList { $1 :: $3 }

InExpr:
  | LEFT_PAREN InList RIGHT_PAREN { List.toArray $2 }

FieldExpr:
  | FieldExpr AND FieldExpr              { FEAnd ($1, $3) }
  | FieldExpr OR FieldExpr               { FEOr ($1, $3) }
  | FieldExpr EQ FieldExpr               { FEEq ($1, $3) }
  | FieldExpr NOT_EQ FieldExpr           { FENotEq ($1, $3) }
  | FieldExpr LIKE STRING                { FELike ($1, $3) }
  | FieldExpr NOT LIKE STRING            { FENotLike ($1, $4) }
  | FieldExpr IN InExpr                  { FEIn ($1, $3) }
  | FieldExpr NOT IN InExpr              { FENotIn ($1, $4) }
  | FieldExpr LESS FieldExpr             { FELess ($1, $3) }
  | FieldExpr LESS_EQ FieldExpr          { FELessEq ($1, $3) }
  | FieldExpr GREATER FieldExpr          { FEGreater ($1, $3) }
  | FieldExpr GREATER_EQ FieldExpr       { FEGreaterEq ($1, $3) }
  | FieldRef                             { FEColumn $1 }
  | ARGUMENT_ID                          { FEPlaceholder $1 }
  | Value                                { FEValue $1 }
  | LEFT_PAREN FieldExpr RIGHT_PAREN     { $2 }

IntArray:
  |                  { [||] }
  | IntArrayNonEmpty { List.toArray $1 }

IntArrayNonEmpty:
  | INT                        { [ $1 ] }
  | INT COMMA IntArrayNonEmpty { $1 :: $3 }

StringArray:
  |                     { [||] }
  | StringArrayNonEmpty { List.toArray $1 }

StringArrayNonEmpty:
  | STRING                           { [ $1 ] }
  | STRING COMMA StringArrayNonEmpty { $1 :: $3 }

BoolArray:
  |                   { [||] }
  | BoolArrayNonEmpty { List.toArray $1 }

BoolArrayNonEmpty:
  | BOOL                         { [ $1 ] }
  | BOOL COMMA BoolArrayNonEmpty { $1 :: $3 }

Value:
  | INT                                    { FInt $1 }
  | STRING                                 { FString $1 }
  | BOOL                                   { FBool $1 }
  | LEFT_BRACKET IntArray    RIGHT_BRACKET { FIntArray $2 }
  | LEFT_BRACKET StringArray RIGHT_BRACKET { FStringArray $2 }
  | LEFT_BRACKET BoolArray   RIGHT_BRACKET { FBoolArray $2 }
  | NULL                                   { FNull }

OrderByClause:
  |                      { [||] }
  | ORDER BY OrderByList { List.toArray $3 }

OrderByList:
  | OrderByExpr                   { [ $1 ] }
  | OrderByExpr COMMA OrderByList { $1 :: $3 }

OrderByExpr:
  | FieldExpr OrderByDirection { ($2, $1) }

OrderByDirection:
  |      { Asc }
  | ASC  { Asc }
  | DESC { Desc }

ScalarType:
  | INT_TYPE      { SFTInt }
  | STRING_TYPE   { SFTString }
  | BOOL_TYPE     { SFTBool }
  | DATETIME_TYPE { SFTDateTime }
  | DATE_TYPE     { SFTDate }

FieldExprType:
  | ScalarType                                    { FETScalar $1 }
  | ARRAY_TYPE LEFT_PAREN ScalarType RIGHT_PAREN  { FETArray $3 }

FieldType:
  | FieldExprType                                                   { FTType $1 }
  | REFERENCE_TYPE LEFT_PAREN EntityRef RIGHT_PAREN                 { FTReference $3 None }
  | REFERENCE_TYPE LEFT_PAREN EntityRef COMMA FieldExpr RIGHT_PAREN { FTReference $3 (Some $5) }
  | ENUM_TYPE LEFT_PAREN EnumList RIGHT_PAREN                       { FTEnum ($3 |> List.toSeq |> setOfSeqUnique) }

ArgumentFieldType:
  | FieldExprType                                                   { FTType $1 }
  | REFERENCE_TYPE LEFT_PAREN EntityRef RIGHT_PAREN                 { FTReference $3 None }
  | ENUM_TYPE LEFT_PAREN EnumList RIGHT_PAREN                       { FTEnum ($3 |> List.toSeq |> setOfSeqUnique) }

EnumList:
  | STRING                { [ $1 ] }
  | STRING COMMA EnumList { $1 :: $3 }
