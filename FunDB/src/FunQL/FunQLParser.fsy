%{

open FunWithFlags.FunDB.Utils
open FunWithFlags.FunDB.FunQL.AST

let private applyJoin fromExpr1 (joinType, fromExpr2, whereExpr) =
    FJoin (joinType, fromExpr1, fromExpr2, whereExpr)

type ParsedFieldExpr = FieldExpr<FieldRef>
type ParsedFromExpr = FromExpr<EntityRef, FieldRef>
type ParsedConditionClause = ConditionClause<EntityRef, FieldRef>
type ParsedFromClause = FromClause<EntityRef, FieldRef>
type ParsedQueryExpr = QueryExpr<EntityRef, FieldRef>
type ParsedQueryResult = QueryResult<FieldRef>type ParsedAttributeMap = AttributeMap<FieldRef>

type ParsedViewExpr =
    { arguments : Map<string, ParsedFieldType>
      attributes : ParsedAttributeMap
      results : ViewResults<FieldRef>
      clause : ParsedFromClause
      updateName : EntityRef option
    }

type private AttributedResult =
    | AResult of ParsedAttributeMap * QueryResult<FieldRef>
    | AAttribute of FunQLName * ParsedFieldExpr

let private parseMap (error : string) (vals : ('k * 'v) seq) : Map<'k, 'v> =
    try
        Map.ofSeqUnique vals
    with
        | Failure msg -> failwith <| sprintf "%s: %s" error msg

let private splitResults (results : AttributedResult seq) : ParsedAttributeMap * ViewResults<FieldRef> =
    let getResult = function
        | AResult (attrs, res) -> Some (attrs, res)
        | AAttribute (name, attr) -> None
    let getAttribute = function
        | AResult (attrs, res) -> None
        | AAttribute (name, attr) -> Some (name, attr)

    let attributes = results |> Seq.mapMaybe getAttribute |> parseMap "Clashing row attribute names"    
    let results = results |> Seq.mapMaybe getResult |> Seq.toArray
    (attributes, results)

// We restrict casts to work only on values to clarify their types. This is becaise arbitrary casting breaks abstractionmatch
let private restrictCast (expr : ParsedFieldExpr) (exprType : FieldExprType) : unit =
    match expr with
        | FEValue v ->
            match (v, exprType) with
                | (FStringArray _, FETArray _) -> ()
                | (FString _, FETScalar _) -> ()
                | (FInt _, FETScalar _) -> ()
                | (FBool _, FETScalar _) -> ()
                | (FNull, _) -> ()
                | _ -> failwith "Casting cannot be performed between arrays and scalars"
        | _ -> failwith <| sprintf "Casting can only be performed on values: %O :: %O" expr exprType

%}

// Atoms
%token <int> INT
%token <string> ID
%token <string> ARGUMENT_ID
%token <string> GLOBAL_ARGUMENT_ID
%token <string> STRING
%token <bool> BOOL
%token NULL

// Symbols
%token LEFT_BRACE
%token RIGHT_BRACE
%token LEFT_PAREN
%token RIGHT_PAREN
%token LEFT_BRACKET
%token RIGHT_BRACKET
%token DOUBLE_COLON
%token COMMA
%token DOT
%token EQ
%token NOT_EQ
%token AT
%token LESS
%token GREATER
%token LESS_EQ
%token GREATER_EQ
%token ARROW
%token CONCAT

// Keywords
%token SELECT
%token FROM
%token WHERE
%token LEFT
%token RIGHT
%token INNER
%token OUTER
%token JOIN
%token ON
%token ORDER
%token BY
%token AS
%token ASC
%token DESC
%token AND
%token OR
%token LIKE
%token IN
%token IS
%token NOT
%token FOR
%token UPDATE
%token OF
%token CASE
%token WHEN
%token THEN
%token ELSE
%token END
%token COALESCE

// Types
%token INT_TYPE
%token STRING_TYPE
%token BOOL_TYPE
%token DATETIME_TYPE
%token DATE_TYPE
%token REFERENCE_TYPE
%token ARRAY_TYPE
%token ENUM_TYPE

// Misc
%token EOF

%left OR
%left AND
%right NOT
%nonassoc EQ NOT_EQ
%nonassoc LESS GREATER LESS_EQ GREATER_EQ
%nonassoc LIKE
%nonassoc IN
%left CONCAT
%nonassoc IS
%left DOUBLE_COLON
%left DOT

%start viewExpr
%type <ParsedViewExpr> viewExpr

%start fieldType
%type <ParsedFieldType> fieldType

%start fieldExpr
%type <ParsedFieldExpr> fieldExpr

%start conditionClause
%type <ParsedConditionClause> conditionClause

%%

// Entry points
viewExpr : ViewExpr EOF { $1 }
fieldExpr : FieldExpr EOF { $1 }
fieldType : FieldType EOF { $1 }
conditionClause : ConditionClause EOF { $1 }

// Expressions

ViewExpr:
  | MaybeArguments SELECT AttributedResults FromClause UpdateClause {
      let (attributes, results) = splitResults $3
      { arguments = $1; attributes = attributes; results = results; clause = $4; updateName = $5 }
  }

UpdateClause:
  |                         { None }
  | FOR UPDATE OF EntityRef { Some $4 }

MaybeArguments:
  |                                            { Map.empty }
  | LEFT_PAREN ArgumentsList RIGHT_PAREN ARROW { $2 }

ArgumentsList:
  |                       { Map.empty }
  | ArgumentsListNonEmpty { parseMap "Clashing argument names" $1 }

ArgumentsListNonEmpty:
  | Argument COMMA ArgumentsListNonEmpty { $1 :: $3 }
  | Argument                             { [ $1 ] }

Argument:
  | ARGUMENT_ID ArgumentFieldType { ($1, $2) }

ConditionClause:
  | WhereClause OrderByClause { { where = $1; orderBy = $2 } }

FromClause:
  | FROM FromExpr ConditionClause { { from = $2; condition = $3 } }

Query:
	| SELECT Results FromClause { { results = $2; clause = $3 } }

Results:
  |                 { [||] }
  | ResultsNonEmpty { List.toArray $1 }

ResultsNonEmpty:
  | Result COMMA ResultsNonEmpty { $1 :: $3 }
  | Result                       { [ $1 ] }

AttributedResults:
  |                           { [] }
  | AttributedResultsNonEmpty { $1 }

AttributedResultsNonEmpty:
  | AttributedResult COMMA AttributedResultsNonEmpty { $1 :: $3 }
  | AttributedResult                                 { [ $1 ] }

AttributedResult:
  | MaybeAttributeMap Result { AResult ($1, $2) }
  | AT ID EQ FieldExpr       { AAttribute (FunQLName $2, $4) }

MaybeAttributeMap:
  |                                                { Map.empty }
  | LEFT_BRACE RIGHT_BRACE                         { Map.empty }
  | LEFT_BRACE AttributeValuesNonEmpty RIGHT_BRACE { parseMap "Clashing attribute names" $2 }

AttributeValuesNonEmpty:
  | ID EQ FieldExpr                               { [(FunQLName $1, $3)] }
  | ID EQ FieldExpr COMMA AttributeValuesNonEmpty { (FunQLName $1, $3) :: $5 }

Result:
  | FieldRef {
      let fieldRef = $1 : FieldRef
      { name = fieldRef.name; expression = FEColumn fieldRef }
  }
  | FieldExpr AS ID { { name = FunQLName $3; expression = $1 } }

QuerySource:
  | LEFT_PAREN Query RIGHT_PAREN AS ID { FSubExpr (FunQLName $5, $2) }
  | EntityRef                          { FEntity ($1) }

JoinType:
  |       { Inner }
  | INNER { Inner }
  | OUTER { Outer }
  | LEFT  { Left  }
  | RIGHT { Right }

JoinChain:
  |                                                  { [] }
  | JoinType JOIN QuerySource ON FieldExpr JoinChain { ($1, $3, $5) :: $6 }

FromExpr:
  | QuerySource JoinChain { List.fold applyJoin $1 $2 }

EntityRef:
  | ID DOT ID { { schema = Some (FunQLName $1); name = FunQLName $3; } }
  | ID        { { schema = None; name = FunQLName $1; } }

FieldRef:
  | ID DOT ID DOT ID { { entity = Some { schema = Some (FunQLName $1); name = FunQLName $3 }; name = FunQLName $5 } }
  | ID DOT ID        { { entity = Some { schema = None; name = FunQLName $1 }; name = FunQLName $3 } }
  | ID               { { entity = None; name = FunQLName $1 } }

WhereClause:
  |                 { None }
  | WHERE FieldExpr { Some $2 }

NonEmptyExprs:
  | FieldExpr                     { [ $1 ] }
  | FieldExpr COMMA NonEmptyExprs { $1 :: $3 }

NonEmptyExprList:
  | LEFT_PAREN NonEmptyExprs RIGHT_PAREN { List.toArray $2 }

FieldExpr:
  | FieldExpr OR FieldExpr  { FEOr ($1, $3) }
  | FieldExpr AND FieldExpr { FEAnd ($1, $3) }
  | NOT FieldExpr           { FENot $2 }
  | FieldExprEq             { $1 }

FieldExprEq:
  | FieldExprOp EQ FieldExprOp          { FEEq ($1, $3) }
  | FieldExprOp NOT_EQ FieldExprOp      { FENotEq ($1, $3) }
  | FieldExprOp LESS FieldExprOp        { FELess ($1, $3) }
  | FieldExprOp LESS_EQ FieldExprOp     { FELessEq ($1, $3) }
  | FieldExprOp GREATER FieldExprOp     { FEGreater ($1, $3) }
  | FieldExprOp GREATER_EQ FieldExprOp  { FEGreaterEq ($1, $3) }
  | FieldExprOp LIKE FieldExprOp        { FELike ($1, $3) }
  | FieldExprOp NOT LIKE FieldExprOp    { FENotLike ($1, $4) }
  | FieldExprOp IN NonEmptyExprList     { FEIn ($1, $3) }
  | FieldExprOp NOT IN NonEmptyExprList { FENotIn ($1, $4) }
  | FieldExprOp                         { $1 }

FieldExprOp:
  | FieldExprOp CONCAT FieldExprOp         { FEConcat ($1, $3) }
  | FieldExprOp DOUBLE_COLON FieldExprType { restrictCast $1 $3; FECast ($1, $3) }
  | COALESCE NonEmptyExprList              { FECoalesce $2 }
  | CaseExpr                               { $1 }
  | FieldExprVal                           { $1 }

FieldExprVal:
  | FieldRef                         { FEColumn $1 }
  | ARGUMENT_ID                      { FEPlaceholder (PLocal $1) }
  | GLOBAL_ARGUMENT_ID               { FEPlaceholder (PGlobal $1) }
  | Value                            { FEValue $1 }
  | LEFT_PAREN FieldExpr RIGHT_PAREN { $2 }

CaseExpr:
  | CASE CaseWhenList CaseElse END { FECase (List.toArray $2, $3) }

CaseWhenList:
  | WHEN FieldExpr THEN FieldExpr CaseWhenList { ($2, $4) :: $5 }
  | WHEN FieldExpr THEN FieldExpr              { [($2, $4)] }

CaseElse:
  |                { None }
  | ELSE FieldExpr { Some $2 }

IntArrayList:
  | INT                    { [ $1 ] }
  | INT COMMA IntArrayList { $1 :: $3 }

IntArrayNonEmpty:
  | IntArrayList { List.toArray $1 }

StringArrayList:
  | STRING                       { [ $1 ] }
  | STRING COMMA StringArrayList { $1 :: $3 }

StringArrayNonEmpty:
  | StringArrayList { List.toArray $1 }

BoolArrayList:
  | BOOL                     { [ $1 ] }
  | BOOL COMMA BoolArrayList { $1 :: $3 }

BoolArrayNonEmpty:
  | BoolArrayList { List.toArray $1 }

Value:
  | INT                                            { FInt $1 }
  | STRING                                         { FString $1 }
  | BOOL                                           { FBool $1 }
  | LEFT_BRACKET RIGHT_BRACKET                     { FStringArray [||] }
  | LEFT_BRACKET StringArrayNonEmpty RIGHT_BRACKET { FStringArray $2 }
  | LEFT_BRACKET IntArrayNonEmpty    RIGHT_BRACKET { FIntArray $2 }
  | LEFT_BRACKET BoolArrayNonEmpty   RIGHT_BRACKET { FBoolArray $2 }
  | NULL                                           { FNull }

OrderByClause:
  |                      { [||] }
  | ORDER BY OrderByList { List.toArray $3 }

OrderByList:
  | OrderByExpr                   { [ $1 ] }
  | OrderByExpr COMMA OrderByList { $1 :: $3 }

OrderByExpr:
  | FieldExpr OrderByDirection { ($2, $1) }

OrderByDirection:
  |      { Asc }
  | ASC  { Asc }
  | DESC { Desc }

ScalarType:
  | INT_TYPE      { SFTInt }
  | STRING_TYPE   { SFTString }
  | BOOL_TYPE     { SFTBool }
  | DATETIME_TYPE { SFTDateTime }
  | DATE_TYPE     { SFTDate }

FieldExprType:
  | ScalarType                                    { FETScalar $1 }
  | ARRAY_TYPE LEFT_PAREN ScalarType RIGHT_PAREN  { FETArray $3 }

FieldType:
  | FieldExprType                                                   { FTType $1 }
  | REFERENCE_TYPE LEFT_PAREN EntityRef RIGHT_PAREN                 { FTReference ($3, None) }
  | REFERENCE_TYPE LEFT_PAREN EntityRef COMMA FieldExpr RIGHT_PAREN { FTReference ($3, Some $5) }
  | ENUM_TYPE LEFT_PAREN EnumList RIGHT_PAREN                       { FTEnum ($3 |> List.toSeq |> Set.ofSeqUnique) }

ArgumentFieldType:
  | FieldExprType                                   { FTType $1 }
  | REFERENCE_TYPE LEFT_PAREN EntityRef RIGHT_PAREN { FTReference ($3, None) }
  | ENUM_TYPE LEFT_PAREN EnumList RIGHT_PAREN       { FTEnum ($3 |> List.toSeq |> Set.ofSeqUnique) }

EnumList:
  | STRING                { [ $1 ] }
  | STRING COMMA EnumList { $1 :: $3 }
