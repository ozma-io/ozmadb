%{

open FunWithFlags.FunDB.Utils
open FunWithFlags.FunDB.FunQL.AST

let private applyJoin fromExpr1 (joinType, fromExpr2, whereExpr) =
    FJoin (joinType, fromExpr1, fromExpr2, whereExpr)

type ParsedFieldExpr = FieldExpr<EntityRef, FieldRef>
type ParsedFromExpr = FromExpr<EntityRef, FieldRef>
type ParsedFromClause = FromClause<EntityRef, FieldRef>
type ParsedSelectExpr = SelectExpr<EntityRef, FieldRef>
type ParsedSingleSelectExpr = SingleSelectExpr<EntityRef, FieldRef>
type ParsedQueryResult = QueryResult<EntityRef, FieldRef>
type ParsedQueryResultExpr = QueryResultExpr<EntityRef, FieldRef>
type ParsedAttributeMap = AttributeMap<EntityRef, FieldRef>
type ParsedOrderLimitClause = OrderLimitClause<EntityRef, FieldRef>

type ParsedMainEntity =
    { entity : EntityRef
    }

type ParsedViewExpr =
    { arguments : Map<string, ParsedFieldType>
      select : ParsedSelectExpr
      mainEntity : ParsedMainEntity option
    }

type private Result =
    | AResult of QueryResult<EntityRef, FieldRef>
    | AAttribute of FunQLName * ParsedFieldExpr

let private parseMap (error : string) (vals : ('k * 'v) seq) : Map<'k, 'v> =
    try
        Map.ofSeqUnique vals
    with
        | Failure msg -> failwith <| sprintf "%s: %s" error msg

let private splitResults (results : Result seq) : ParsedAttributeMap * QueryResult<'e, 'f>[] =
    let getResult = function
        | AResult res -> Some res
        | AAttribute (name, attr) -> None
    let getAttribute = function
        | AResult res -> None
        | AAttribute (name, attr) -> Some (name, attr)

    let attributes = results |> Seq.mapMaybe getAttribute |> parseMap "Clashing row attribute names"
    let results = results |> Seq.mapMaybe getResult |> Seq.toArray
    (attributes, results)

// We restrict casts to work only on values to clarify their types. This is because arbitrary casting breaks abstraction
let private restrictCast (expr : ParsedFieldExpr) (exprType : FieldExprType) : unit =
    match expr with
        | FEValue v ->
            match (v, exprType) with
                | (FStringArray _, FETArray _) -> ()
                | (FString _, FETScalar _) -> ()
                | (FInt _, FETScalar _) -> ()
                | (FBool _, FETScalar _) -> ()
                | (FNull, _) -> ()
                | _ -> failwith "Casting cannot be performed between arrays and scalars"
        | _ -> failwith <| sprintf "Casting can only be performed on values: %O :: %O" expr exprType

%}

// Atoms
%token <int> INT
%token <decimal> DECIMAL
%token <string> ID
%token <string> ARGUMENT_ID
%token <string> GLOBAL_ARGUMENT_ID
%token <string> STRING
%token <bool> BOOL
%token NULL

// Symbols
%token LEFT_BRACE
%token RIGHT_BRACE
%token LEFT_PAREN
%token RIGHT_PAREN
%token LEFT_BRACKET
%token RIGHT_BRACKET
%token DOUBLE_COLON
%token COMMA
%token DOT
%token EQ
%token NOT_EQ
%token AT
%token LESS
%token GREATER
%token LESS_EQ
%token GREATER_EQ
%token ARROW
%token CONCAT
%token STAR
%token AT_LEFT_BRACE
%token LIKE_OP
%token NOT_LIKE_OP

// Keywords
%token SELECT
%token FROM
%token WHERE
%token LEFT
%token RIGHT
%token INNER
%token OUTER
%token JOIN
%token ON
%token ORDER
%token BY
%token AS
%token ASC
%token DESC
%token AND
%token OR
%token LIKE
%token IN
%token IS
%token NOT
%token FOR
%token INSERT
%token INTO
%token CASE
%token WHEN
%token THEN
%token ELSE
%token END
%token COALESCE
%token LIMIT
%token OFFSET
%token UNION
%token INTERSECT
%token EXCEPT
%token UPDATE
%token OF

// Types
%token INT_TYPE
%token DECIMAL_TYPE
%token STRING_TYPE
%token BOOL_TYPE
%token DATETIME_TYPE
%token DATE_TYPE
%token REFERENCE_TYPE
%token ARRAY_TYPE
%token ENUM_TYPE

// Misc
%token EOF

%left OR
%left AND
%right NOT
%nonassoc EQ NOT_EQ
%nonassoc LESS GREATER LESS_EQ GREATER_EQ
%nonassoc LIKE LIKE_OP NOT_LIKE_OP
%nonassoc IN
%left CONCAT
%nonassoc IS
%left DOUBLE_COLON
%left DOT

%start viewExpr
%type <ParsedViewExpr> viewExpr

%start fieldType
%type <ParsedFieldType> fieldType

%start fieldExpr
%type <ParsedFieldExpr> fieldExpr

%%

// Entry points
viewExpr : ViewExpr EOF { $1 }
fieldExpr : FieldExpr EOF { $1 }
fieldType : FieldType EOF { $1 }

// Expressions

ViewExpr:
  | MaybeArguments SelectExpr InsertEntityClause { { arguments = $1; select = $2; mainEntity = $3 } }

MaybeArguments:
  |                                            { Map.empty }
  | LEFT_PAREN ArgumentsList RIGHT_PAREN ARROW { $2 }

ArgumentsList:
  |                       { Map.empty }
  | ArgumentsListNonEmpty { parseMap "Clashing argument names" $1 }

ArgumentsListNonEmpty:
  | Argument COMMA ArgumentsListNonEmpty { $1 :: $3 }
  | Argument                             { [ $1 ] }

Argument:
  | ARGUMENT_ID ArgumentFieldType { ($1, $2) }

SelectVal:
  | SingleUnlimitedSelectExpr         { SSelect $1 }
  | LEFT_BRACE SelectExpr RIGHT_BRACE { $2 }

SelectExpr:
  | SingleSelectExpr                           { SSelect $1 }
  | LEFT_BRACE SelectExpr RIGHT_BRACE          { $2 }
  | SelectVal SetOp SetOpExpr OrderLimitClause { SSetOp ($2, $1, $3, $4) }

SetOp:
  | UNION     { Union }
  | INTERSECT { Intersect }
  | EXCEPT    { Except }

SetOpExpr:
  | SelectVal                 { $1 }
  | SelectVal SetOp SetOpExpr { SSetOp ($2, $1, $3, emptyOrderLimitClause) }

SingleSelectExpr:
  | SELECT QueryResults FromClause OrderLimitClause {
    let (attributes, results) = splitResults $2
    { attributes = attributes; results = results; clause = $3; orderLimit = $4 }
  }

SingleUnlimitedSelectExpr:
  | SELECT QueryResults FromClause {
    let (attributes, results) = splitResults $2
    { attributes = attributes; results = results; clause = $3; orderLimit = emptyOrderLimitClause }
  }

OrderLimitClause:
  | OrderByClause LimitClause OffsetClause { { orderBy = $1; limit = $2; offset = $3 } }

OrderByClause:
  |                      { [||] }
  | ORDER BY OrderByList { List.toArray $3 }

OrderByList:
  | OrderByExpr                   { [ $1 ] }
  | OrderByExpr COMMA             { [ $1 ] }
  | OrderByExpr COMMA OrderByList { $1 :: $3 }

OrderByExpr:
  | FieldExpr OrderByDirection { ($2, $1) }

OrderByDirection:
  |      { Asc }
  | ASC  { Asc }
  | DESC { Desc }

LimitClause:
  |                 { None }
  | LIMIT FieldExpr { Some $2 }

OffsetClause:
  |                  { None }
  | OFFSET FieldExpr { Some $2 }

FromClause:
  |                           { None }
  | FROM FromExpr WhereClause { Some { from = $2; where = $3 } }

InsertEntityClause:
  |                           { None }
  | FOR INSERT INTO EntityRef { Some { entity = $4 } }
  | FOR UPDATE OF EntityRef   { eprintfn "Deprecated FOR INSERT INTO syntax"; Some { entity = $4 } }

QueryResults:
  | QueryResult COMMA QueryResults { $1 :: $3 }
  | QueryResult                    { [ $1 ] }
  |                                { [] }

QueryResult:
  | AT ID EQ FieldExpr                { AAttribute (FunQLName $2, $4) }
  | QueryResultExpr MaybeAttributeMap { AResult { attributes = $2; result = $1 } }
  | MaybeAttributeMap QueryResultExpr { eprintfn "Deprecated result attribute map order"; AResult { attributes = $1; result = $2 } }

QueryResultExpr:
  | FieldRef        { QRField $1 }
  | FieldExpr AS ID { QRExpr (FunQLName $3, $1) }

MaybeAttributeMap:
  |                                                   { Map.empty }
  | AT_LEFT_BRACE RIGHT_BRACE                         { Map.empty }
  | AT_LEFT_BRACE AttributeValuesNonEmpty RIGHT_BRACE { parseMap "Clashing attribute names" $2 }
  | LEFT_BRACE RIGHT_BRACE                            { eprintfn "Deprecated result attribute map syntax"; Map.empty }
  | LEFT_BRACE AttributeValuesNonEmpty RIGHT_BRACE    { eprintfn "Deprecated result attribute map syntax"; parseMap "Clashing attribute names" $2 }

AttributeValuesNonEmpty:
  | ID EQ FieldExpr                               { [(FunQLName $1, $3)] }
  | ID EQ FieldExpr COMMA                         { [(FunQLName $1, $3)] }
  | ID EQ FieldExpr COMMA AttributeValuesNonEmpty { (FunQLName $1, $3) :: $5 }

QuerySource:
  | LEFT_PAREN SelectExpr RIGHT_PAREN AS ID { FSubExpr (FunQLName $5, $2) }
  | EntityRef                               { FEntity ($1) }

JoinType:
  |       { Inner }
  | INNER { Inner }
  | OUTER { Outer }
  | LEFT  { Left  }
  | RIGHT { Right }

JoinChain:
  |                                                  { [] }
  | JoinType JOIN QuerySource ON FieldExpr JoinChain { ($1, $3, $5) :: $6 }

FromExpr:
  | QuerySource JoinChain { List.fold applyJoin $1 $2 }

EntityRef:
  | ID DOT ID { { schema = Some (FunQLName $1); name = FunQLName $3; } }
  | ID        { { schema = None; name = FunQLName $1; } }

FieldRef:
  | ID DOT ID DOT ID { { entity = Some { schema = Some (FunQLName $1); name = FunQLName $3 }; name = FunQLName $5 } }
  | ID DOT ID        { { entity = Some { schema = None; name = FunQLName $1 }; name = FunQLName $3 } }
  | ID               { { entity = None; name = FunQLName $1 } }

WhereClause:
  |                 { None }
  | WHERE FieldExpr { Some $2 }

NonEmptyExprs:
  | FieldExpr                     { [ $1 ] }
  | FieldExpr COMMA NonEmptyExprs { $1 :: $3 }

NonEmptyExprList:
  | LEFT_PAREN NonEmptyExprs RIGHT_PAREN { List.toArray $2 }

FieldExpr:
  | FieldExpr OR FieldExpr  { FEOr ($1, $3) }
  | FieldExpr AND FieldExpr { FEAnd ($1, $3) }
  | NOT FieldExpr           { FENot $2 }
  | FieldExprEq             { $1 }

FieldExprEq:
  | FieldExprOp EQ FieldExprOp          { FEEq ($1, $3) }
  | FieldExprOp NOT_EQ FieldExprOp      { FENotEq ($1, $3) }
  | FieldExprOp LESS FieldExprOp        { FELess ($1, $3) }
  | FieldExprOp LESS_EQ FieldExprOp     { FELessEq ($1, $3) }
  | FieldExprOp GREATER FieldExprOp     { FEGreater ($1, $3) }
  | FieldExprOp GREATER_EQ FieldExprOp  { FEGreaterEq ($1, $3) }
  | FieldExprOp IS NULL                 { FEIsNull $1 }
  | FieldExprOp IS NOT NULL             { FEIsNotNull $1 }
  | FieldExprOp LIKE FieldExprOp        { FELike ($1, $3) }
  | FieldExprOp NOT LIKE FieldExprOp    { FENotLike ($1, $4) }
  | FieldExprOp LIKE_OP FieldExprOp     { FELike ($1, $3) }
  | FieldExprOp NOT_LIKE_OP FieldExprOp { FENotLike ($1, $3) }
  | FieldExprOp IN NonEmptyExprList     { FEIn ($1, $3) }
  | FieldExprOp NOT IN NonEmptyExprList { FENotIn ($1, $4) }
  | FieldExprOp                         { $1 }

FieldExprOp:
  | FieldExprOp CONCAT FieldExprOp         { FEConcat ($1, $3) }
  | FieldExprOp DOUBLE_COLON FieldExprType { restrictCast $1 $3; FECast ($1, $3) }
  | COALESCE NonEmptyExprList              { FECoalesce $2 }
  | CaseExpr                               { $1 }
  | FieldExprVal                           { $1 }

FieldExprVal:
  | FieldRef                         { FEColumn $1 }
  | ARGUMENT_ID                      { FEPlaceholder (PLocal $1) }
  | GLOBAL_ARGUMENT_ID               { FEPlaceholder (PGlobal $1) }
  | Value                            { FEValue $1 }
  | LEFT_PAREN FieldExpr RIGHT_PAREN { $2 }

CaseExpr:
  | CASE CaseWhenList CaseElse END { FECase (List.toArray $2, $3) }

CaseWhenList:
  | WHEN FieldExpr THEN FieldExpr CaseWhenList { ($2, $4) :: $5 }
  | WHEN FieldExpr THEN FieldExpr              { [($2, $4)] }

CaseElse:
  |                { None }
  | ELSE FieldExpr { Some $2 }

IntArrayList:
  | INT                    { [ $1 ] }
  | INT COMMA IntArrayList { $1 :: $3 }

IntArrayNonEmpty:
  | IntArrayList { List.toArray $1 }

StringArrayList:
  | STRING                       { [ $1 ] }
  | STRING COMMA StringArrayList { $1 :: $3 }

StringArrayNonEmpty:
  | StringArrayList { List.toArray $1 }

BoolArrayList:
  | BOOL                     { [ $1 ] }
  | BOOL COMMA BoolArrayList { $1 :: $3 }

BoolArrayNonEmpty:
  | BoolArrayList { List.toArray $1 }

DecimalArrayList:
  | DECIMAL                        { [ $1 ] }
  | DECIMAL COMMA DecimalArrayList { $1 :: $3 }

DecimalArrayNonEmpty:
  | DecimalArrayList { List.toArray $1 }

Value:
  | INT                                             { FInt $1 }
  | DECIMAL                                         { FDecimal $1 }
  | STRING                                          { FString $1 }
  | BOOL                                            { FBool $1 }
  | LEFT_BRACKET RIGHT_BRACKET                      { FStringArray [||] }
  | LEFT_BRACKET StringArrayNonEmpty  RIGHT_BRACKET { FStringArray $2 }
  | LEFT_BRACKET IntArrayNonEmpty     RIGHT_BRACKET { FIntArray $2 }
  | LEFT_BRACKET BoolArrayNonEmpty    RIGHT_BRACKET { FBoolArray $2 }
  | LEFT_BRACKET DecimalArrayNonEmpty RIGHT_BRACKET { FDecimalArray $2 }
  | NULL                                            { FNull }

ScalarType:
  | INT_TYPE      { SFTInt }
  | DECIMAL_TYPE  { SFTDecimal }
  | STRING_TYPE   { SFTString }
  | BOOL_TYPE     { SFTBool }
  | DATETIME_TYPE { SFTDateTime }
  | DATE_TYPE     { SFTDate }

FieldExprType:
  | ScalarType                                    { FETScalar $1 }
  | ARRAY_TYPE LEFT_PAREN ScalarType RIGHT_PAREN  { FETArray $3 }

FieldType:
  | FieldExprType                                                   { FTType $1 }
  | REFERENCE_TYPE LEFT_PAREN EntityRef RIGHT_PAREN                 { FTReference ($3, None) }
  | REFERENCE_TYPE LEFT_PAREN EntityRef COMMA FieldExpr RIGHT_PAREN { FTReference ($3, Some $5) }
  | ENUM_TYPE LEFT_PAREN EnumList RIGHT_PAREN                       { FTEnum ($3 |> List.toSeq |> Set.ofSeqUnique) }

ArgumentFieldType:
  | FieldExprType                                   { FTType $1 }
  | REFERENCE_TYPE LEFT_PAREN EntityRef RIGHT_PAREN { FTReference ($3, None) }
  | ENUM_TYPE LEFT_PAREN EnumList RIGHT_PAREN       { FTEnum ($3 |> List.toSeq |> Set.ofSeqUnique) }

EnumList:
  | STRING                { [ $1 ] }
  | STRING COMMA EnumList { $1 :: $3 }