%{

open System
open System.Globalization

open FunWithFlags.FunDB.Utils
open FunWithFlags.FunDB.Attribute
open FunWithFlags.FunDB.FunQL.AST

let applyJoin fromExpr1 (joinType, fromExpr2, whereExpr) =
    FJoin(joinType, fromExpr1, fromExpr2, whereExpr)

%}

// Atoms
%token <int> INT
%token <double> FLOAT
%token <string> ID
%token <string> STRING
%token <bool> BOOL
%token NULL

// Symbols
%token LEFT_BRACE
%token RIGHT_BRACE
%token LEFT_BRACKET
%token RIGHT_BRACKET
%token LEFT_PARENS
%token RIGHT_PARENS
%token SEMICOLON
%token DOUBLE_COLON
%token COLON
%token COMMA
%token DOT
%token EQ

// Keywords
%token SELECT
%token FROM
%token WHERE
%token LEFT
%token RIGHT
%token INNER
%token OUTER
%token JOIN
%token ON
%token ORDER
%token BY
%token AS
%token ASC
%token DESC
%token AND

// Types
%token INT_TYPE
%token STRING_TYPE
%token BOOL_TYPE
%token DATETIME_TYPE
%token DATE_TYPE
%token REFERENCE_TYPE
%token ENUM_TYPE

// Misc
%token EOF

%left AND
%right EQ
%left DOUBLE_COLON
%left DOT

%start query
%type <ParsedQueryExpr> query

%start fieldType
%type <ParsedFieldType> fieldType

%start fieldExpr
%type <ParsedFieldExpr> fieldExpr

%%

// Entry points
query: Query EOF { $1 }
fieldExpr : FieldExpr EOF { $1 }
fieldType : FieldType EOF { $1 }

// Expressions
Query:
	| MaybeAttributeMap SELECT Results FROM FromExpr WhereClause OrderByClause { { attributes = $1; results = List.toArray $3; from = $5; where = $6; orderBy = List.toArray $7; } }

MaybeAttributeMap:
  |              { new AttributeMap() }
  | AttributeMap { $1 }

Results:
  |                 { [] }
  | ResultsNonEmpty { $1 }

ResultsNonEmpty:
  | AttributedResult COMMA ResultsNonEmpty { $1 :: $3 }
  | AttributedResult                       { [ $1 ] }

AttributedResult:
  | MaybeAttributeMap Result { ($1, $2) }

AttributeMap:
  | LEFT_BRACE AttributeValues RIGHT_BRACE { new AttributeMap($2 |> Map.toSeq |> dict) }

AttributeValues:
  |                                              { Map.empty }
  | ID COLON Attribute SEMICOLON AttributeValues { Map.add $1 $3 $5 }

Attribute:
  | BOOL          { ABool($1) }
  | FLOAT         { AFloat($1) }
  | INT           { AInt($1) }
  | STRING        { AString($1) }
  | AttributeList { AList($1) }
  | AttributeMap  { AAssoc($1) }

AttributeList:
  | LEFT_BRACKET AttributeItems RIGHT_BRACKET { List.toArray $2 }

AttributeItems:
  |                        { [] }
  | AttributeItemsNonEmpty { $1 }

AttributeItemsNonEmpty:
  | Attribute                              { [ $1 ] }
  | Attribute COMMA AttributeItemsNonEmpty { $1 :: $3 }

Result:
  | FieldName       { RField($1) }
  | FieldExpr AS ID { RExpr($3, $1) }

QuerySource:
  | LEFT_PARENS Query RIGHT_PARENS AS ID { FSubExpr($5, $2) }
  | EntityName                           { FEntity($1) }

JoinType:
  |       { Inner }
  | INNER { Inner }
  | OUTER { Outer }
  | LEFT  { Left  }
  | RIGHT { Right }

JoinChain:
  | { [] }
  | JoinType JOIN QuerySource ON FieldExpr JoinChain { ($1, $3, $5) :: $6 }

FromExpr:
  | QuerySource JoinChain { List.fold applyJoin $1 $2 }

EntityName:
  | ID DOT ID { { schema = Some($1); name = $3; } }
  | ID        { { schema = None; name = $1; } }

FieldName:
  | ID DOT ID DOT ID { { entity = Some({ schema = Some($1); name = $3; }); name = $5; } }
  | ID DOT ID        { { entity = Some({ schema = None; name = $1; }); name = $3; } }
  | ID               { { entity = None; name = $1; } }

WhereClause:
  |                 { None }
  | WHERE FieldExpr { Some($2) }

FieldExpr:
  | FieldExpr AND FieldExpr { FEAnd($1, $3) }
  | FieldExpr EQ FieldExpr { FEEq($1, $3) }
  // Special cases to be able to use Date and DateTime constants
  | STRING DOUBLE_COLON DATE_TYPE     { FEValue(FDate(tryDateTimeInvariant $1 |> Option.get)) }
  | STRING DOUBLE_COLON DATETIME_TYPE { FEValue(FDateTime(tryDateTimeInvariant $1 |> Option.get)) }
  // FIXME: Implement actual casting.
  | FieldName                                 { FEColumn($1) }
  | Value                                     { FEValue($1) }
  | LEFT_PARENS FieldExpr RIGHT_PARENS        { $2 }

Value:
  | INT                                { FInt($1) }
  | STRING                             { FString($1) }
  | BOOL                               { FBool($1) }
  | NULL                               { FNull }

OrderByClause:
  |                      { [ ] }
  | ORDER BY OrderByList { $3 }

OrderByList:
  | OrderByExpr                   { [$1] }
  | OrderByExpr COMMA OrderByList { $1 :: $3 }

OrderByExpr:
  | FieldExpr OrderByDirection { ($2, $1) }

OrderByDirection:
  |      { Asc }
  | ASC  { Asc }
  | DESC { Desc }

FieldExprType:
  | INT_TYPE                                           { FTInt }
  | STRING_TYPE                                        { FTString }
  | BOOL_TYPE                                          { FTBool }
  | DATETIME_TYPE                                      { FTDateTime }
  | DATE_TYPE                                          { FTDate }

FieldType:
  | FieldExprType                                      { $1 }
  | REFERENCE_TYPE LEFT_PARENS EntityName RIGHT_PARENS { FTReference($3) }
  | ENUM_TYPE LEFT_PARENS EnumList RIGHT_PARENS        { FTEnum($3 |> List.toSeq |> setOfSeqUnique) }

EnumList:
  | STRING                { [$1] }
  | STRING COMMA EnumList { $1 :: $3 }
