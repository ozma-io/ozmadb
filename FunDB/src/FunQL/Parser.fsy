%{

open FunWithFlags.FunDB.Attribute
open FunWithFlags.FunDB.SQL.Value
open FunWithFlags.FunDB.SQL.Parse
open FunWithFlags.FunDB.FunQL.AST

let applyJoin fromExpr1 (joinType, fromExpr2, whereExpr) =
    FJoin(joinType, fromExpr1, fromExpr2, whereExpr)

%}

// Atoms
%token <int> INT
%token <double> FLOAT
%token <string> ID
%token <string> STRING
%token <bool> BOOL
%token NULL

// Symbols
%token DOUBLE_COLON
%token LEFT_BRACE
%token RIGHT_BRACE
%token LEFT_BRACKET
%token RIGHT_BRACKET
%token LEFT_PARENS
%token RIGHT_PARENS
%token SEMICOLON
%token COMMA
%token DOT
%token EQ

// Keywords
%token SELECT
%token FROM
%token WHERE
%token LEFT
%token RIGHT
%token INNER
%token OUTER
%token JOIN
%token ON
%token ORDER
%token BY
%token AS
%token ASC
%token DESC
%token AND

// Types
%token INT_TYPE
%token STRING_TYPE
%token BOOL_TYPE
%token REFERENCE_TYPE

// Misc
%token EOF

%left AND

%start query
%type <ParsedQueryExpr> query

%start fieldType
%type <ParsedFieldType> fieldType

%start value
%type <Value> value

%start valueExpr
%type <ParsedValueExpr> valueExpr

%%

// Entry points
query: Query EOF { $1 }
valueExpr : ValueExpr EOF { $1 }
value : Value EOF { $1 }
fieldType : FieldType EOF { $1 }

// Expressions
Query:
	| MaybeAttributeMap SELECT Results FROM FromExpr WhereClause OrderByClause { { attributes = $1; results = List.toArray $3; from = $5; where = $6; orderBy = List.toArray $7; } }

MaybeAttributeMap:
  |              { new AttributeMap() }
  | AttributeMap { $1 }

Results:
  | AttributedResult COMMA Results { $1 :: $3 }
  | AttributedResult               { [ $1 ] }

AttributedResult:
  | Result MaybeAttributeMap { ($1, $2) }

AttributeMap:
  | LEFT_BRACE AttributeValues RIGHT_BRACE { new AttributeMap($2 |> Map.toSeq |> dict) }

AttributeValues:
  | { Map.empty }
  | ID EQ Attribute SEMICOLON AttributeValues { Map.add $1 $3 $5 }

Attribute:
  | BOOL          { ABool($1) }
  | FLOAT         { AFloat($1) }
  | INT           { AInt($1) }
  | STRING        { AString($1) }
  | AttributeList { AList($1) }
  | AttributeMap  { AAssoc($1) }

AttributeList:
  | LEFT_BRACKET AttributeItems RIGHT_BRACKET { List.toArray $2 }

AttributeItems:
  | { [] }
  | Attribute { [ $1 ] }
  | Attribute COMMA AttributeItems { $1 :: $3 }

Result:
  | FieldName { RField($1) }
  | ValueExpr AS ID { RExpr($1, $3) }

QuerySource:
  | LEFT_PARENS Query RIGHT_PARENS AS ID { FSubExpr($2, $5) }
  | EntityName                           { FEntity($1) }

JoinType:
  |       { Inner }
  | INNER { Inner }
  | OUTER { Outer }
  | LEFT  { Left  }
  | RIGHT { Right }

JoinChain:
  | { [] }
  | JoinType JOIN QuerySource ON ValueExpr JoinChain { ($1, $3, $5) :: $6 }

FromExpr:
  | QuerySource JoinChain { List.fold applyJoin $1 $2 }

EntityName:
  | ID DOT ID { { schema = Some($1); name = $3; } }
  | ID        { { schema = None; name = $1; } }

FieldName:
  | ID DOT ID DOT ID { { entity = Some({ schema = Some($1); name = $3; }); name = $5; } }
  | ID DOT ID        { { entity = Some({ schema = None; name = $1; }); name = $3; } }
  | ID               { { entity = None; name = $1; } }

WhereClause:
  |                 { None }
  | WHERE ValueExpr { Some($2) }

ValueExprList:
  |                               { [] }
  | ValueExpr COMMA ValueExprList { $1 :: $3 }

ValueExpr:
  | ValueExprAnd                              { $1 }

ValueExprAnd:
  | ValueExprEq AND ValueExprAnd { WAnd($1, $3) }
  | ValueExprEq                  { $1 }
  
ValueExprEq:
  | ValueExprEq EQ ValueExprVal { WEq($1, $3) }
  | ValueExprCast               { $1 }

ValueExprCast:
  | ValueExprCast DOUBLE_COLON ID { WCast($1, $3 |> parseValueType |> Option.get) }
  | ValueExprVal                  { $1 }

ValueExprVal:
  | ID LEFT_PARENS ValueExprList RIGHT_PARENS { WFunc($1, List.toArray $3) }
  | FieldName                                 { WColumn($1) }
  | Value                                     { WValue($1) }
  | LEFT_PARENS ValueExpr RIGHT_PARENS        { $2 }

Value:
  | INT                                { VInt($1) }
  | FLOAT                              { VFloat($1) }
  | STRING                             { VString($1) }
  | BOOL                               { VBool($1) }
  | NULL                               { VNull }

OrderByClause:
  |                      { [ ] }
  | ORDER BY OrderByList { $3 }

OrderByList:
  | OrderByExpr                   { [$1] }
  | OrderByExpr COMMA OrderByList { $1 :: $3 }

OrderByExpr:
  | FieldName                  { ($1, Asc) }
  | FieldName OrderByDirection { ($1, $2) }

OrderByDirection:
  | ASC  { Asc }
  | DESC { Desc }

FieldType:
  | INT_TYPE                  { FTInt }
  | STRING_TYPE               { FTString }
  | BOOL_TYPE                 { FTBool }
  | REFERENCE_TYPE EntityName { FTReference($2) }
