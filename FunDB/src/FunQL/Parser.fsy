%{

open FunWithFlags.FunDB.Escape
open FunWithFlags.FunDB.Attribute
open FunWithFlags.FunDB.FunQL.AST

let applyJoin fromExpr1 (joinType, fromExpr2, whereExpr) =
    FJoin(joinType, fromExpr1, fromExpr2, whereExpr)

%}

// Atoms
%token <int> INT
%token <double> FLOAT
%token <string> ID
%token <string> STRING
%token LEFT_BRACE
%token RIGHT_BRACE
%token LEFT_BRACKET
%token RIGHT_BRACKET
%token LEFT_PARENS
%token RIGHT_PARENS
%token COLON
%token SEMICOLON
%token COMMA
%token DOT
%token EQ

// Keywords
%token NULL
%token TRUE
%token FALSE
%token SELECT
%token FROM
%token WHERE
%token LEFT
%token RIGHT
%token INNER
%token OUTER
%token JOIN
%token ON
%token ORDER
%token BY
%token AS
%token ASC
%token DESC
%token AND

// Types
%token INT_TYPE
%token STRING_TYPE
%token REFERENCE_TYPE

// Misc
%token EOF

%left AND

%start query
%type <ParsedQueryExpr> query

%start fieldType
%type <ParsedFieldType> fieldType

%start value
%type <Value> value

%%

query: Query EOF { $1 }

Query:
	| SELECT Results FROM FromExpr WhereClause OrderByClause { { results = List.toArray $2; from = $4; where = $5; orderBy = List.toArray $6; } }

Results:
  | AttributedResult COMMA Results { $1 :: $3 }
  | AttributedResult               { [ $1 ] }

AttributedResult:
  | Result { ($1, new AttributeMap()) }
  | Result AttributeMap { ($1, $2) }

Bool:
  | TRUE  { true }
  | FALSE { false }

AttributeMap:
  | LEFT_BRACE AttributeValues RIGHT_BRACE { new AttributeMap($2 |> Map.toSeq |> dict) }

AttributeValues:
  | { Map.empty }
  | ID EQ Attribute SEMICOLON AttributeValues { Map.add $1 $3 $5 }

Attribute:
  | Bool          { ABool($1) }
  | FLOAT         { AFloat($1) }
  | INT           { AInt($1) }
  | STRING        { AString($1) }
  | AttributeList { AList($1) }
  | AttributeMap  { AAssoc($1) }

AttributeList:
  | LEFT_BRACKET AttributeItems RIGHT_BRACKET { List.toArray $2 }

AttributeItems:
  | { [] }
  | Attribute { [ $1 ] }
  | Attribute COMMA AttributeItems { $1 :: $3 }

Result:
  | FieldName { RField($1) }
  | ResultExpr AS ID { RExpr($1, $3) }

ResultExpr:
  | FieldName { REField($1) }

QuerySource:
  | LEFT_PARENS Query RIGHT_PARENS AS ID { FSubExpr($2, $5) }
  | EntityName                           { FEntity($1) }

JoinType:
  |       { Inner }
  | INNER { Inner }
  | OUTER { Outer }
  | LEFT  { Left  }
  | RIGHT { Right }

JoinChain:
  | { [] }
  | JoinType JOIN QuerySource ON ValueExpr JoinChain { ($1, $3, $5) :: $6 }

FromExpr:
  | QuerySource JoinChain { List.fold applyJoin $1 $2 }

EntityName:
  | ID DOT ID { { schema = Some($1); name = $3; } }
  | ID        { { schema = None; name = $1; } }

FieldName:
  | ID DOT ID DOT ID { { entity = Some({ schema = Some($1); name = $3; }); name = $5; } }
  | ID DOT ID        { { entity = Some({ schema = None; name = $1; }); name = $3; } }
  | ID               { { entity = None; name = $1; } }

WhereClause:
  |                 { None }
  | WHERE ValueExpr { Some($2) }

ValueExpr:
  | ValueExpr AND ValueExpr { WAnd($1, $3) }
  | ValueExprOp             { $1 }

ValueExprOp:
  | ValueExprVal                 { $1 }
  | ValueExprVal EQ ValueExprVal { WEq($1, $3) }

ValueExprVal:
  | FieldName                          { WField($1) }
  | Value                              { WValue($1) }
  | LEFT_PARENS ValueExpr RIGHT_PARENS { $2 }

Value:
  | INT                                { VInt($1) }
  | FLOAT                              { VFloat($1) }
  | STRING                             { VString($1) }
  | Bool                               { VBool($1) }
  | NULL                               { VNull }

OrderByClause:
  |                      { [ ] }
  | ORDER BY OrderByList { $3 }

OrderByList:
  | OrderByExpr                   { [$1] }
  | OrderByExpr COMMA OrderByList { $1 :: $3 }

OrderByExpr:
  | FieldName                  { ($1, Asc) }
  | FieldName OrderByDirection { ($1, $2) }

OrderByDirection:
  | ASC  { Asc }
  | DESC { Desc }

fieldType: FieldType EOF { $1 }

FieldType:
  | INT_TYPE                  { FTInt }
  | STRING_TYPE               { FTString }
  | REFERENCE_TYPE EntityName { FTReference($2) }

value: Value EOF { $1 }
