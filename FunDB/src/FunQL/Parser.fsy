%{

open FunWithFlags.FunDB.Attribute
open FunWithFlags.FunDB.FunQL.AST

let applyJoin fromExpr1 (joinType, fromExpr2, whereExpr) =
    FJoin(joinType, fromExpr1, fromExpr2, whereExpr)

type EntityName =
    { schema: string option;
      name: TableName;
    }

// FIXME: allow non-qualified field names, like in SQL
type FieldName =
    { entity: EntityName;
      name: ColumnName;
    }

type ParsedQueryExpr = QueryExpr<EntityName, FieldName>

%}

// The start token becomes a parser function in the compiled code:
%start start

// Atoms
%token <int> INT
%token <double> FLOAT
%token <string> ID
%token <string> STRING
%token LEFT_BRACE
%token RIGHT_BRACE
%token LEFT_BRACKET
%token RIGHT_BRACKET
%token LEFT_PARENS
%token RIGHT_PARENS
%token COLON
%token SEMICOLON
%token COMMA
%token DOT
%token EQ

// Keywords
%token NULL
%token TRUE
%token FALSE
%token SELECT
%token FROM
%token WHERE
%token LEFT
%token RIGHT
%token INNER
%token OUTER
%token JOIN
%token ON
%token ORDER
%token BY
%token AS
%token ASC
%token DESC

// Misc
%token EOF

// This is the type of the data produced by a successful reduction of the 'start'
// symbol:
%type <ParsedQueryExpr> start

%%

start: Query EOF { $1 }

Query:
	| SELECT Results FROM FromExpr WhereClause OrderByClause { { results = $2; from = $4; where = $5; orderBy = $6; } }

Results:
  | AttributedResult COMMA Results { $1 :: $3 }
  | AttributedResult               { [ $1 ] }

AttributedResult:
  | Result { ($1, Map.empty) }
  | Result AttributeMap { ($1, $2) }

Bool:
  | TRUE  { true }
  | FALSE { false }

AttributeMap:
  | LEFT_BRACE AttributeValues RIGHT_BRACE { $2 }

AttributeValues:
  | { Map.empty }
  | ID EQ Attribute SEMICOLON AttributeValues { Map.add $1 $3 $5 }

Attribute:
  | Bool          { ABool($1) }
  | FLOAT         { AFloat($1) }
  | INT           { AInt($1) }
  | STRING        { AString($1) }
  | AttributeList { AList($1) }
  | AttributeMap  { AAssoc($1) }

AttributeList:
  | LEFT_BRACKET AttributeItems RIGHT_BRACKET { $2 }

AttributeItems:
  | { [] }
  | Attribute { [ $1 ] }
  | Attribute COMMA AttributeItems { $1 :: $3 }

Result:
  | FieldName { RField($1) }
  | ResultExpr AS ID { RExpr($1, $3) }

ResultExpr:
  | FieldName { REField($1) }

QuerySource:
  | LEFT_PARENS Query RIGHT_PARENS AS ID { FSubExpr($2, $5) }
  | EntityName                           { FEntity($1) }

JoinType:
  |       { Inner }
  | INNER { Inner }
  | OUTER { Outer }
  | LEFT  { Left  }
  | RIGHT { Right }

JoinChain:
  | { [] }
  | JoinType JOIN QuerySource ON WhereExpr JoinChain { ($1, $3, $5) :: $6 }

FromExpr:
  | QuerySource JoinChain { List.fold applyJoin $1 $2 }

EntityName:
  | ID        { { schema = None; name = $1; } }
  | ID DOT ID { { schema = Some($1); name = $3; } }

FieldName:
  | ID DOT ID        { { entity = { schema = None; name = $1; }; name = $3; } }
  | ID DOT ID DOT ID { { entity = { schema = Some($1); name = $3; }; name = $5; } }

WhereClause:
  |                 { None }
  | WHERE WhereExpr { Some($2) }

WhereValue:
  | FieldName              { WField($1) }
  | INT                    { WInt($1) }
  | FLOAT                  { WFloat($1) }
  | STRING                 { WString($1) }
  | Bool                   { WBool($1) }

WhereExpr:
  | WhereValue               { $1 }
  | WhereValue EQ WhereValue { WEq($1, $3) }

OrderByClause:
  |                      { [ ] }
  | ORDER BY OrderByList { $3 }

OrderByList:
  | OrderByExpr                   { [$1] }
  | OrderByExpr COMMA OrderByList { $1 :: $3 }

OrderByExpr:
  | FieldName                  { ($1, Asc) }
  | FieldName OrderByDirection { ($1, $2) }

OrderByDirection:
  | ASC  { Asc }
  | DESC { Desc }
