%{

open Newtonsoft.Json.Linq

open FunWithFlags.FunDB.Utils
open FunWithFlags.FunDB.Json
open FunWithFlags.FunDB.FunQL.AST

type ParsedFieldExpr = FieldExpr<EntityRef, LinkedFieldRef>
type ParsedFromExpr = FromExpr<EntityRef, LinkedFieldRef>
type ParsedSelectExpr = SelectExpr<EntityRef, LinkedFieldRef>
type ParsedSingleSelectExpr = SingleSelectExpr<EntityRef, LinkedFieldRef>
type ParsedQueryResult = QueryResult<EntityRef, LinkedFieldRef>
type ParsedQueryResultExpr = QueryResultExpr<EntityRef, LinkedFieldRef>
type ParsedAttributeMap = AttributeMap<EntityRef, LinkedFieldRef>
type ParsedOrderLimitClause = OrderLimitClause<EntityRef, LinkedFieldRef>
type ParsedAggExpr = AggExpr<EntityRef, LinkedFieldRef>

type ParsedMainEntity =
    { entity : EntityRef
    }

[<NoComparison>]
type ParsedViewExpr =
    { arguments : Map<ArgumentName, ParsedArgument>
      select : ParsedSelectExpr
      mainEntity : ParsedMainEntity option
    }

[<NoComparison>]
type private Result =
    | AResult of QueryResult<EntityRef, LinkedFieldRef>
    | AAttribute of FunQLName * ParsedFieldExpr

[<NoComparison>]
type private InSource =
    | ISValues of ParsedFieldExpr[]
    | ISSelect of ParsedSelectExpr

let private inExpr (valuesConstr : (ParsedFieldExpr * ParsedFieldExpr[]) -> ParsedFieldExpr)
                   (selectConstr : (ParsedFieldExpr * ParsedSelectExpr) -> ParsedFieldExpr)
                   (needle : ParsedFieldExpr)
                   (haystack : InSource) : ParsedFieldExpr =
    match haystack with
    | ISValues vals -> valuesConstr (needle, vals)
    | ISSelect sel -> selectConstr (needle, sel)

let private extractInOneSource : ParsedFieldExpr[] -> InSource = function
    | [| FESubquery sel |] -> ISSelect sel
    | vals -> ISValues vals

let private parseMap (error : string) (vals : ('k * 'v) seq) : Map<'k, 'v> =
    try
        Map.ofSeqUnique vals
    with
        | Failure msg -> failwith <| sprintf "%s: %s" error msg

let private splitResults (results : Result seq) : ParsedAttributeMap * QueryResult<'e, 'f>[] =
    let getResult = function
        | AResult res -> Some res
        | AAttribute (name, attr) -> None
    let getAttribute = function
        | AResult res -> None
        | AAttribute (name, attr) -> Some (name, attr)

    let attributes = results |> Seq.mapMaybe getAttribute |> parseMap "Clashing row attribute names"
    let results = results |> Seq.mapMaybe getResult |> Seq.toArray
    (attributes, results)

// We restrict casts to work only on values to clarify their types. This is because arbitrary casting breaks abstraction
let private restrictCast (expr : ParsedFieldExpr) (exprType : FieldExprType) : unit =
    match expr with
        | FEValue v ->
            match (v, exprType) with
                | (FStringArray _, FETArray _) -> ()
                | (FString _, FETScalar _) -> ()
                | (FInt _, FETScalar _) -> ()
                | (FBool _, FETScalar _) -> ()
                | (FNull, _) -> ()
                | _ -> failwith "Casting cannot be performed between arrays and scalars"
        | _ -> failwith <| sprintf "Casting can only be performed on values: %O :: %O" expr exprType

let private applyJoin fromExpr1 (joinType, fromExpr2, whereExpr) =
    FJoin (joinType, fromExpr1, fromExpr2, whereExpr)

let private valueToJson : FieldValue -> JToken = function
    | FInt i -> JToken.op_Implicit i
    | FDecimal d -> JToken.op_Implicit d
    | FString s -> JToken.op_Implicit s
    | FBool b -> JToken.op_Implicit b
    | FJson j -> j
    | FStringArray ss -> ss |> Seq.map JToken.op_Implicit |> jsonArray :> JToken
    | FIntArray ss -> ss |> Seq.map JToken.op_Implicit |> jsonArray :> JToken
    | FBoolArray ss -> ss |> Seq.map JToken.op_Implicit |> jsonArray :> JToken
    | FDecimalArray ss -> ss |> Seq.map JToken.op_Implicit |> jsonArray :> JToken
    | FJsonArray ss -> jsonArray ss :> JToken
    | FNull -> JValue.CreateNull() :> JToken
    // Keep in sync with coalesceJsonObject!
    | (FUserViewRef _ as v)
    | (FUserViewRefArray _ as v)
    | (FDate _ as v)
    | (FDateTime _ as v)
    | (FDateArray _ as v)
    | (FDateTimeArray _ as v) ->
      failwith <| sprintf "Encountered impossible value %O while converting to JSON in parser" v

let private validJsonValue = function
    // Keep in sync with valueToJson!
    | FUserViewRef _
    | FUserViewRefArray _
    | FDate _
    | FDateTime _
    | FDateArray _
    | FDateTimeArray _ -> false
    | _ -> true

let private coalesceJsonObject (exprs : (string * ParsedFieldExpr) list) : ParsedFieldExpr =
    let rec tryExtract = function
        | [] -> Some []
        | ((name, FEValue v) :: t) when validJsonValue v -> Option.map (fun nt -> (name, v) :: nt) (tryExtract t)
        | _ -> None

    match tryExtract exprs with
    | None -> FEJsonObject (exprs |> Seq.map (fun (name, e) -> (FunQLName name, e)) |> Map.ofSeq)
    | Some vals -> FEValue (FJson (vals |> Seq.map (fun (name, v) -> (name, valueToJson v)) |> jsonObject))

let private coalesceJsonArray (exprs : ParsedFieldExpr list) : ParsedFieldExpr =
    let rec tryExtract = function
        | [] -> Some []
        | ((FEValue v) :: t) when validJsonValue v -> Option.map (fun nt -> v :: nt) (tryExtract t)
        | _ -> None

    match tryExtract exprs with
    | None -> FEJsonArray (List.toArray exprs)
    | Some vals -> FEValue (FJson (vals |> Seq.map valueToJson |> jsonArray))

let private makeFunc (name : FunQLName) (exprs : ParsedFieldExpr array) : ParsedFieldExpr =
    if Set.contains name allowedFunctions then
        FEFunc (name, exprs)
    else if Set.contains name allowedAggregateFunctions && Array.length exprs > 0 then
        FEAggFunc (name, AEAll exprs)
    else
        failwithf "Unknown or applied incorrectly function %O" name

let private makeAggFunc (name : FunQLName) (expr : ParsedAggExpr) : ParsedFieldExpr =
    if Set.contains name allowedAggregateFunctions then
        match expr with
        | AEAll exprs when Array.length exprs = 0 -> failwithf "No arguments to an aggregate function %O" name
        | _ -> ()
        FEAggFunc (name, expr)
    else
        failwithf "Unknown aggregate function %O" name

%}

// Atoms
%token <int> INT
%token <decimal> DECIMAL
%token <string> ID
%token <string> ARGUMENT_ID
%token <string> GLOBAL_ARGUMENT_ID
%token <string> STRING
%token <bool> BOOL
%token NULL

// Symbols
%token LEFT_BRACE
%token RIGHT_BRACE
%token LEFT_PAREN
%token RIGHT_PAREN
%token LEFT_BRACKET
%token RIGHT_BRACKET
%token DOUBLE_COLON
%token COLON
%token COMMA
%token DOT
%token EQ
%token NOT_EQ
%token AT
%token LESS
%token GREATER
%token LESS_EQ
%token GREATER_EQ
%token BOLD_ARROW
%token CONCAT
%token STAR
%token AT_LEFT_BRACE
%token LIKE_OP
%token NOT_LIKE_OP
%token ARROW
%token DOUBLE_ARROW
%token PLUS
%token MINUS
%token MULTIPLY
%token DIVIDE
%token AMPERSAND

// Keywords
%token SELECT
%token FROM
%token WHERE
%token LEFT
%token RIGHT
%token INNER
%token OUTER
%token JOIN
%token ON
%token ORDER
%token BY
%token AS
%token ASC
%token DESC
%token AND
%token OR
%token LIKE
%token IN
%token IS
%token NOT
%token FOR
%token INSERT
%token INTO
%token CASE
%token WHEN
%token THEN
%token ELSE
%token END
%token COALESCE
%token LIMIT
%token OFFSET
%token UNION
%token INTERSECT
%token EXCEPT
%token UPDATE
%token OF
%token VALUES
%token DISTINCT
%token ALL
%token GROUP
%token ARRAY
%token INHERITED
%token OFTYPE

// Types
%token INT_TYPE
%token DECIMAL_TYPE
%token STRING_TYPE
%token BOOL_TYPE
%token DATETIME_TYPE
%token DATE_TYPE
%token REFERENCE_TYPE
%token ENUM_TYPE
%token JSON_TYPE
%token UVREF_TYPE

// Misc
%token EOF

%left OR
%left AND
%right NOT
%nonassoc EQ NOT_EQ
%nonassoc LESS GREATER LESS_EQ GREATER_EQ
%nonassoc LIKE LIKE_OP NOT_LIKE_OP
%nonassoc IN
%left CONCAT ARROW DOUBLE_ARROW
%nonassoc IS
%left PLUS MINUS
%left MULTIPLY DIVIDE
%left DOUBLE_COLON
%left DOT

%start viewExpr
%type <ParsedViewExpr> viewExpr

%start fieldType
%type <ParsedFieldType> fieldType

%start fieldExpr
%type <ParsedFieldExpr> fieldExpr

%start attributeMap
%type <ParsedAttributeMap> attributeMap

%type <FieldRef> FieldRef

%%

// Entry points
viewExpr : ViewExpr EOF { $1 }
fieldExpr : FieldExpr EOF { $1 }
fieldType : FieldType EOF { $1 }
attributeMap : AttributeMap EOF { $1 }

// Expressions

ViewExpr:
  | MaybeArguments UnparenSelectExpr InsertEntityClause { { arguments = $1; select = $2; mainEntity = $3 } }

MaybeArguments:
  |                                            { Map.empty }
  | LEFT_BRACE ArgumentsList RIGHT_BRACE COLON { $2 }

ArgumentsList:
  |                       { Map.empty }
  | ArgumentsListNonEmpty { parseMap "Clashing argument names" $1 }

ArgumentsListNonEmpty:
  | ArgumentEntry COMMA ArgumentsListNonEmpty { $1 :: $3 }
  | ArgumentEntry                             { [ $1 ] }

ArgumentEntry:
  | ARGUMENT_ID Argument { (FunQLName $1, $2) }

Argument:
  | ArgumentFieldType      { { argType = $1; optional = false } }
  | ArgumentFieldType NULL { { argType = $1; optional = true } }

SelectVal:
  | SingleUnlimitedSelectExpr { SSelect $1 }
  | SubSelectExpr             { $1 }

// We don't allow select expressions with nested parentheses now because it's difficult to implement as LALR(1) for all our cases (or I'm missing something obvious).
UnparenSelectExpr:
  | SingleSelectExpr                           { SSelect $1 }
  | SelectVal SetOp SetOpExpr OrderLimitClause { SSetOp ($2, $1, $3, $4) }

SubSelectExpr:
  | LEFT_PAREN UnparenSelectExpr RIGHT_PAREN { $2 }

SetOp:
  | UNION     { Union }
  | INTERSECT { Intersect }
  | EXCEPT    { Except }

SetOpExpr:
  | SelectVal                 { $1 }
  | SelectVal SetOp SetOpExpr { SSetOp ($2, $1, $3, emptyOrderLimitClause) }

SingleSelectExpr:
  | SingleUnlimitedSelectExpr OrderLimitClause { { $1 with orderLimit = $2 } }

SingleUnlimitedSelectExpr:
  | SELECT QueryResults FromClause WhereClause GroupByClause {
    let (attributes, results) = splitResults $2
    { attributes = attributes
      results = results
      from = $3
      where = $4
      groupBy = $5
      orderLimit = emptyOrderLimitClause
      extra = null
    }
  }

OrderLimitClause:
  | OrderByClause LimitClause OffsetClause { { orderBy = $1; limit = $2; offset = $3 } }

OrderByClause:
  |                      { [||] }
  | ORDER BY OrderByList { List.toArray $3 }

OrderByList:
  | OrderByExpr                   { [ $1 ] }
  | OrderByExpr COMMA             { [ $1 ] }
  | OrderByExpr COMMA OrderByList { $1 :: $3 }

OrderByExpr:
  | FieldExpr OrderByDirection { ($2, $1) }

OrderByDirection:
  |      { Asc }
  | ASC  { Asc }
  | DESC { Desc }

LimitClause:
  |                 { None }
  | LIMIT FieldExpr { Some $2 }

OffsetClause:
  |                  { None }
  | OFFSET FieldExpr { Some $2 }

FromClause:
  |               { None }
  | FROM FromExpr { Some $2 }

InsertEntityClause:
  |                           { None }
  | FOR INSERT INTO EntityRef { Some { entity = $4 } }

QueryResults:
  | QueryResult COMMA QueryResults { $1 :: $3 }
  | QueryResult                    { [ $1 ] }
  |                                { [] }

QueryResult:
  | AT Name EQ FieldExpr                { AAttribute ($2, $4) }
  | QueryResultExpr MaybeAttributeMap   { AResult { attributes = $2; result = $1 } }

QueryResultExpr:
  | FieldExpr         { QRExpr (None, $1) }
  | FieldExpr AS Name { QRExpr (Some $3, $1) }

MaybeAttributeMap:
  |                                                   { Map.empty }
  | AttributeMap                                      { $1 }

AttributeMap:
  | AT_LEFT_BRACE RIGHT_BRACE                         { Map.empty }
  | AT_LEFT_BRACE AttributeValuesNonEmpty RIGHT_BRACE { parseMap "Clashing attribute names" $2 }

AttributeValuesNonEmpty:
  | Name EQ FieldExpr                               { [($1, $3)] }
  | Name EQ FieldExpr COMMA                         { [($1, $3)] }
  | Name EQ FieldExpr COMMA AttributeValuesNonEmpty { ($1, $3) :: $5 }

QuerySource:
  | SubSelectExpr AS Name                               { FSubExpr ($3, $1) }
  | LEFT_PAREN Values RIGHT_PAREN AS Name ColumnAliases { FValues ($5, $6, $2) }
  | EntityRef                                           { FEntity (None, $1) }
  | EntityRef AS Name                                   { FEntity (Some $3, $1) }
  | LEFT_PAREN FromExpr RIGHT_PAREN                     { $2 }

ColumnAliases:
  | LEFT_PAREN ColumnAliasesList RIGHT_PAREN { List.toArray $2 }

ColumnAliasesList:
  | Name                         { [$1] }
  | Name COMMA ColumnAliasesList { $1 :: $3 }

Values:
  | VALUES ValuesEntryList { List.toArray $2 }

ValuesEntryList:
  | ValuesEntry                       { [$1] }
  | ValuesEntry COMMA ValuesEntryList { $1 :: $3 }

ValuesEntry:
  | LEFT_PAREN ValueItemsList RIGHT_PAREN { List.toArray $2 }

ValueItemsList:
  | FieldExpr                      { [$1]  }
  | FieldExpr COMMA ValueItemsList { $1 :: $3 }

JoinType:
  |       { Inner }
  | INNER { Inner }
  | OUTER { Outer }
  | LEFT  { Left  }
  | RIGHT { Right }

JoinChain:
  |                                                  { [] }
  | JoinType JOIN QuerySource ON FieldExpr JoinChain { ($1, $3, $5) :: $6 }

FromExpr:
  | QuerySource JoinChain { List.fold applyJoin $1 $2 }

EntityRef:
  | Name DOT Name { { schema = Some $1; name = $3; } }
  | Name          { { schema = None; name = $1; } }

ValueRef:
  | FieldRef           { VRColumn $1 }
  | ARGUMENT_ID        { VRPlaceholder (PLocal <| FunQLName $1) }
  | GLOBAL_ARGUMENT_ID { VRPlaceholder (PGlobal <| FunQLName $1) }

LinkedValueRef:
  | ValueRef LinkedFieldsList { { ref = $1; path = List.toArray $2 } }

LinkedFieldsList:
  |                                  { List.empty }
  | BOLD_ARROW Name LinkedFieldsList { $2 :: $3 }

FieldRef:
  | Name DOT Name DOT Name { { entity = Some { schema = Some $1; name = $3 }; name = $5 } }
  | Name DOT Name          { { entity = Some { schema = None; name = $1 }; name = $3 } }
  | Name                   { { entity = None; name = $1 } }

WhereClause:
  |                 { None }
  | WHERE FieldExpr { Some $2 }

GroupByClause:
  |                           { [||] }
  | GROUP BY NonEmptyExprList { $3 }

NonEmptyExprs:
  | FieldExpr { [ $1 ] }
  | FieldExpr COMMA { [ $1 ] }
  | FieldExpr COMMA NonEmptyExprs { $1 :: $3 }

NonEmptyExprList:
  | NonEmptyExprs { List.toArray $1 }

ParenedNonEmptyExprList:
  | LEFT_PAREN NonEmptyExprList RIGHT_PAREN { $2 }

ExprList:
  |                  { [||] }
  | NonEmptyExprList { $1 }

ParenedExprList:
  | LEFT_PAREN ExprList RIGHT_PAREN { $2 }

FieldExpr:
  | FieldExpr OR FieldExpr  { FEOr ($1, $3) }
  | FieldExpr AND FieldExpr { FEAnd ($1, $3) }
  | NOT FieldExpr           { FENot $2 }
  | FieldExprEq             { $1 }

// Implemented in this way because there is a conflict between multi-paren-ed SelectExpr and FieldExpr with a SelectExpr inside.
FieldInSource:
  | SubSelectExpr           { ISSelect $1 }
  | ParenedNonEmptyExprList { extractInOneSource $1 }

FieldExprEq:
  | FieldExprOp EQ FieldExprOp          { FEEq ($1, $3) }
  | FieldExprOp NOT_EQ FieldExprOp      { FENotEq ($1, $3) }
  | FieldExprOp LESS FieldExprOp        { FELess ($1, $3) }
  | FieldExprOp LESS_EQ FieldExprOp     { FELessEq ($1, $3) }
  | FieldExprOp GREATER FieldExprOp     { FEGreater ($1, $3) }
  | FieldExprOp GREATER_EQ FieldExprOp  { FEGreaterEq ($1, $3) }
  | FieldExprOp IS NULL                 { FEIsNull $1 }
  | FieldExprOp IS NOT NULL             { FEIsNotNull $1 }
  | FieldExprOp LIKE FieldExprOp        { FELike ($1, $3) }
  | FieldExprOp NOT LIKE FieldExprOp    { FENotLike ($1, $4) }
  | FieldExprOp LIKE_OP FieldExprOp     { FELike ($1, $3) }
  | FieldExprOp NOT_LIKE_OP FieldExprOp { FENotLike ($1, $3) }
  | FieldExprOp IN FieldInSource        { inExpr FEIn FEInQuery $1 $3 }
  | FieldExprOp NOT IN FieldInSource    { inExpr FENotIn FENotInQuery $1 $4 }
  | FieldExprOp                         { $1 }

FieldExprOp:
  | FieldExprOp CONCAT FieldExprOp         { FEConcat ($1, $3) }
  | FieldExprOp ARROW FieldExprOp          { FEJsonArrow ($1, $3) }
  | FieldExprOp DOUBLE_ARROW FieldExprOp   { FEJsonTextArrow ($1, $3) }
  | FieldExprOp DOUBLE_COLON FieldExprType { restrictCast $1 $3; FECast ($1, $3) }
  | COALESCE ParenedNonEmptyExprList       { FECoalesce $2 }
  | CaseExpr                               { $1 }
  | FieldExprVal                           { $1 }

FieldExprVal:
  | LinkedValueRef INHERITED FROM EntityRef { FEInheritedFrom ($1, { ref = $4; extra = null }) }
  | LinkedValueRef OFTYPE EntityRef         { FEOfType ($1, { ref = $3; extra = null }) }
  | LinkedValueRef                          { FERef $1 }
  | Value                                   { FEValue $1 }
  | Name ParenedExprList                    { makeFunc $1 $2 }
  | Name LEFT_PAREN AggFuncArgs RIGHT_PAREN { makeAggFunc $1 $3 }
  | JsonObject                              { $1 }
  | SubSelectExpr                           { FESubquery $1 }
  | LEFT_PAREN FieldExpr RIGHT_PAREN        { $2 }

AggFuncArgs:
  | ALL ExprList       { AEAll $2 }
  | DISTINCT FieldExpr { AEDistinct $2 }
  | STAR               { AEStar }

CaseExpr:
  | CASE CaseWhenList CaseElse END { FECase (List.toArray $2, $3) }

CaseWhenList:
  | WHEN FieldExpr THEN FieldExpr CaseWhenList { ($2, $4) :: $5 }
  | WHEN FieldExpr THEN FieldExpr              { [($2, $4)] }

CaseElse:
  |                { None }
  | ELSE FieldExpr { Some $2 }

IntArrayList:
  | INT                    { [ $1 ] }
  | INT COMMA IntArrayList { $1 :: $3 }

IntArrayNonEmpty:
  | IntArrayList { List.toArray $1 }

StringArrayList:
  | STRING                       { [ $1 ] }
  | STRING COMMA StringArrayList { $1 :: $3 }

StringArrayNonEmpty:
  | StringArrayList { List.toArray $1 }

BoolArrayList:
  | BOOL                     { [ $1 ] }
  | BOOL COMMA BoolArrayList { $1 :: $3 }

BoolArrayNonEmpty:
  | BoolArrayList { List.toArray $1 }

DecimalArrayList:
  | DECIMAL                        { [ $1 ] }
  | DECIMAL COMMA DecimalArrayList { $1 :: $3 }

DecimalArrayNonEmpty:
  | DecimalArrayList { List.toArray $1 }

UserViewRefArrayList:
  | UserViewRef                            { [ $1 ] }
  | UserViewRef COMMA UserViewRefArrayList { $1 :: $3 }

UserViewRefArrayNonEmpty:
  | UserViewRefArrayList { List.toArray $1 }

Value:
  | INT                                    { FInt $1 }
  | DECIMAL                                { FDecimal $1 }
  | STRING                                 { FString $1 }
  | BOOL                                   { FBool $1 }
  | UserViewRef                            { FUserViewRef $1 }
  | LEFT_BRACKET Array RIGHT_BRACKET       { $2 } // Deprecated syntax
  | ARRAY LEFT_BRACKET Array RIGHT_BRACKET { $3 }
  | NULL                                   { FNull }

Array:
  |                          { FStringArray [||] }
  | StringArrayNonEmpty      { FStringArray $1 }
  | IntArrayNonEmpty         { FIntArray $1 }
  | BoolArrayNonEmpty        { FBoolArray $1 }
  | DecimalArrayNonEmpty     { FDecimalArray $1 }
  | UserViewRefArrayNonEmpty { FUserViewRefArray $1 }

UserViewRef:
  | AMPERSAND EntityRef { $2 }

JsonObject:
  | LEFT_BRACE JsonFields RIGHT_BRACE { coalesceJsonObject $2 }

JsonFields:
  |                            { [] }
  | JsonField                  { [$1] }
  | JsonField COMMA JsonFields { $1 :: $3 }

JsonField:
  | ID COLON FieldExpr { ($1, $3) }

JsonArray:
  | LEFT_BRACKET JsonItems RIGHT_BRACKET { coalesceJsonArray $2 }

JsonItems:
  |                           { [] }
  | FieldExpr                 { [$1] }
  | FieldExpr COMMA JsonItems { $1 :: $3 }

ScalarType:
  | INT_TYPE      { SFTInt }
  | DECIMAL_TYPE  { SFTDecimal }
  | STRING_TYPE   { SFTString }
  | BOOL_TYPE     { SFTBool }
  | DATETIME_TYPE { SFTDateTime }
  | DATE_TYPE     { SFTDate }
  | JSON_TYPE     { SFTJson }
  | UVREF_TYPE    { SFTUserViewRef }

FieldExprType:
  | ScalarType                               { FETScalar $1 }
  | ARRAY LEFT_PAREN ScalarType RIGHT_PAREN  { FETArray $3 }

FieldType:
  | FieldExprType                                                   { FTType $1 }
  | REFERENCE_TYPE LEFT_PAREN EntityRef RIGHT_PAREN                 { FTReference ($3, None) }
  | REFERENCE_TYPE LEFT_PAREN EntityRef COMMA FieldExpr RIGHT_PAREN { FTReference ($3, Some $5) }
  | ENUM_TYPE LEFT_PAREN EnumList RIGHT_PAREN                       { FTEnum ($3 |> List.toSeq |> Set.ofSeqUnique) }

ArgumentFieldType:
  | FieldExprType                                   { FTType $1 }
  | REFERENCE_TYPE LEFT_PAREN EntityRef RIGHT_PAREN { FTReference ($3, None) }
  | ENUM_TYPE LEFT_PAREN EnumList RIGHT_PAREN       { FTEnum ($3 |> List.toSeq |> Set.ofSeqUnique) }

EnumList:
  | STRING                { [ $1 ] }
  | STRING COMMA EnumList { $1 :: $3 }

Name:
  | ID { FunQLName $1 }