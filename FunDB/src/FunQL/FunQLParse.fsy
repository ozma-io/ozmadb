%{

open Newtonsoft.Json.Linq

open FunWithFlags.FunUtils
open FunWithFlags.FunUtils.Serialization.Json
open FunWithFlags.FunDB.FunQL.AST

type ParsedFieldExpr = FieldExpr<EntityRef, LinkedFieldRef>
type ParsedFromExpr = FromExpr<EntityRef, LinkedFieldRef>
type ParsedSelectExpr = SelectExpr<EntityRef, LinkedFieldRef>
type ParsedSelectTreeExpr = SelectTreeExpr<EntityRef, LinkedFieldRef>
type ParsedSetOperationExpr = SetOperationExpr<EntityRef, LinkedFieldRef>
type ParsedSingleSelectExpr = SingleSelectExpr<EntityRef, LinkedFieldRef>
type ParsedQueryResult = QueryResult<EntityRef, LinkedFieldRef>
type ParsedQueryColumnResult = QueryColumnResult<EntityRef, LinkedFieldRef>
type ParsedAttributeMap = AttributeMap<EntityRef, LinkedFieldRef>
type ParsedCommonTableExpr = CommonTableExpr<EntityRef, LinkedFieldRef>
type ParsedCommonTableExprs = CommonTableExprs<EntityRef, LinkedFieldRef>
type ParsedOrderLimitClause = OrderLimitClause<EntityRef, LinkedFieldRef>
type ParsedAggExpr = AggExpr<EntityRef, LinkedFieldRef>
type ParsedArgumentsMap = Map<ArgumentName, ParsedArgument>

type ParsedMainEntity =
    { Entity : EntityRef
    }

[<NoComparison>]
type ParsedViewExpr =
    { Arguments : ParsedArgumentsMap
      Select : ParsedSelectExpr
      MainEntity : ParsedMainEntity option
    }

[<NoComparison>]
type private Result =
    | AResult of QueryResult<EntityRef, LinkedFieldRef>
    | AAttribute of FunQLName * ParsedFieldExpr

[<NoComparison>]
type private InSource =
    | ISValues of ParsedFieldExpr[]
    | ISSelect of ParsedSelectExpr

let private inExpr (valuesConstr : (ParsedFieldExpr * ParsedFieldExpr[]) -> ParsedFieldExpr)
                   (selectConstr : (ParsedFieldExpr * ParsedSelectExpr) -> ParsedFieldExpr)
                   (needle : ParsedFieldExpr)
                   (haystack : InSource) : ParsedFieldExpr =
    match haystack with
    | ISValues vals -> valuesConstr (needle, vals)
    | ISSelect sel -> selectConstr (needle, sel)

let private extractInOneSource : ParsedFieldExpr[] -> InSource = function
    | [| FESubquery sel |] -> ISSelect sel
    | vals -> ISValues vals

let private parseMap (error : string) (vals : ('k * 'v) seq) : Map<'k, 'v> =
    try
        Map.ofSeqUnique vals
    with
        | Failure msg -> failwith <| sprintf "%s: %s" error msg

let private splitResults (results : Result seq) : ParsedAttributeMap * QueryResult<'e, 'f>[] =
    let getResult = function
        | AResult res -> Some res
        | AAttribute (name, attr) -> None
    let getAttribute = function
        | AResult res -> None
        | AAttribute (name, attr) -> Some (name, attr)

    let attributes = results |> Seq.mapMaybe getAttribute |> parseMap "Clashing row attribute names"
    let results = results |> Seq.mapMaybe getResult |> Seq.toArray
    (attributes, results)

// We restrict casts to work only on values to clarify their types. This is because arbitrary casting breaks array abstraction, allowing to create nested arrays.
let private restrictCast (expr : ParsedFieldExpr) (exprType : FieldExprType) : unit =
    match expr with
    | FEValue v ->
        match v with
        | FNull -> ()
        | FStringArray _
        | FIntArray _
        | FBoolArray _
        | FDecimalArray _
        | FJsonArray _
        | FUserViewRefArray _
        | FDateArray _
        | FDateTimeArray _
        | FIntervalArray _
        | FUuidArray _ ->
            match exprType with
            | FETArray _ -> ()
            | FETScalar _ -> failwith "Casting cannot be performed between arrays and scalars"
        | FString _
        | FInt _
        | FDecimal _
        | FBool _
        | FJson _
        | FUserViewRef _
        | FDate _
        | FDateTime _
        | FInterval _
        | FUuid _ ->
            match exprType with
            | FETScalar _ -> ()
            | FETArray _ -> failwith "Casting cannot be performed between arrays and scalars"
    | _ ->
        match exprType with
        | FETScalar _ -> ()
        | FETArray _ -> failwith "Cannot cast arbitrary values to arrays"

let private applyJoin fromExpr1 (joinType, fromExpr2, whereExpr) =
    FJoin { Type = joinType; A = fromExpr1; B = fromExpr2; Condition = whereExpr }

let private validJsonValue = function
    | FUserViewRef _
    | FUserViewRefArray _ -> false // We need to first dereference them.
    | _ -> true

let private coalesceJsonObject (exprs : (string * ParsedFieldExpr) list) : ParsedFieldExpr =
    let rec tryExtract = function
        | [] -> Some []
        | ((name, FEValue v) :: t) when validJsonValue v -> Option.map (fun nt -> (name, v) :: nt) (tryExtract t)
        | _ -> None

    match tryExtract exprs with
    | None -> FEJsonObject (exprs |> Seq.map (fun (name, e) -> (FunQLName name, e)) |> Map.ofSeq)
    | Some vals -> FEValue (FJson (vals |> Seq.map (fun (name, v) -> (name, JToken.FromObject v)) |> jsonObject))

let private coalesceJsonArray (exprs : ParsedFieldExpr list) : ParsedFieldExpr =
    let rec tryExtract = function
        | [] -> Some []
        | ((FEValue v) :: t) when validJsonValue v -> Option.map (fun nt -> v :: nt) (tryExtract t)
        | _ -> None

    match tryExtract exprs with
    | None -> FEJsonArray (List.toArray exprs)
    | Some vals -> FEValue (FJson (vals |> Seq.map JToken.FromObject |> jsonArray))

let private makeFunc (name : FunQLName) (exprs : ParsedFieldExpr array) : ParsedFieldExpr =
    if Map.containsKey name allowedFunctions then
        FEFunc (name, exprs)
    else if Map.containsKey name allowedAggregateFunctions && Array.length exprs > 0 then
        FEAggFunc (name, AEAll exprs)
    else
        failwithf "Unknown or applied incorrectly function %O" name

let private makeAggFunc (name : FunQLName) (expr : ParsedAggExpr) : ParsedFieldExpr =
    if Map.containsKey name allowedAggregateFunctions then
        match expr with
        | AEAll exprs when Array.length exprs = 0 -> failwithf "No arguments to an aggregate function %O" name
        | _ -> ()
        FEAggFunc (name, expr)
    else
        failwithf "Unknown aggregate function %O" name

%}

// Atoms
%token <int> INT
%token <decimal> DECIMAL
%token <string> ID
%token <string> ARGUMENT_ID
%token <string> GLOBAL_ARGUMENT_ID
%token <string> STRING
%token <bool> BOOL
%token NULL

// Symbols
%token LEFT_BRACE
%token RIGHT_BRACE
%token LEFT_PAREN
%token RIGHT_PAREN
%token LEFT_BRACKET
%token RIGHT_BRACKET
%token DOUBLE_COLON
%token COLON
%token COMMA
%token DOT
%token EQ
%token NOT_EQ
%token AT
%token LESS
%token GREATER
%token LESS_EQ
%token GREATER_EQ
%token BOLD_ARROW
%token CONCAT
%token AT_LEFT_BRACE
%token LIKE_OP
%token NOT_LIKE_OP
%token ILIKE_OP
%token NOT_ILIKE_OP
%token ARROW
%token DOUBLE_ARROW
%token PLUS
%token MINUS
%token MULTIPLY
%token DIVIDE
%token AMPERSAND
%token MATCH_REGEX
%token MATCH_REGEX_CI
%token NOT_MATCH_REGEX
%token NOT_MATCH_REGEX_CI

// Keywords
%token SELECT
%token FROM
%token WHERE
%token LEFT
%token RIGHT
%token INNER
%token OUTER
%token JOIN
%token ON
%token ORDER
%token BY
%token AS
%token ASC
%token DESC
%token AND
%token OR
%token LIKE
%token ILIKE
%token SIMILAR
%token IN
%token IS
%token TO
%token NOT
%token FOR
%token INSERT
%token INTO
%token CASE
%token WHEN
%token THEN
%token ELSE
%token END
%token LIMIT
%token OFFSET
%token UNION
%token INTERSECT
%token EXCEPT
%token UPDATE
%token OF
%token VALUES
%token DISTINCT
%token ALL
%token GROUP
%token ARRAY
%token INHERITED
%token OFTYPE
%token WITH
%token RECURSIVE
%token ANY
%token SOME

// Types
%token INT_TYPE
%token DECIMAL_TYPE
%token STRING_TYPE
%token BOOL_TYPE
%token DATETIME_TYPE
%token DATE_TYPE
%token INTERVAL_TYPE
%token REFERENCE_TYPE
%token ENUM_TYPE
%token JSON_TYPE
%token UVREF_TYPE
%token UUID_TYPE

// Misc
%token EOF


%left OR
%left AND
%right NOT
// Non-assoc doesn't work correctly in F#: https://github.com/fsprojects/FsLexYacc/issues/39
%nonassoc IS
%nonassoc EQ NOT_EQ LESS_EQ LESS GREATER GREATER_EQ
%nonassoc IN LIKE ILIKE SIMILAR
%left LIKE_OP NOT_LIKE_OP ILIKE_OP NOT_ILIKE_OP MATCH_REGEX MATCH_REGEX_CI NOT_MATCH_REGEX NOT_MATCH_REGEX_CI CONCAT ARROW DOUBLE_ARROW
%left PLUS MINUS
%left MULTIPLY DIVIDE
%left DOUBLE_COLON
%left DOT

%start viewExpr
%type <ParsedViewExpr> viewExpr

%start fieldType
%type <ParsedFieldType> fieldType

%start fieldExpr
%type <ParsedFieldExpr> fieldExpr

%start attributeMap
%type <ParsedAttributeMap> attributeMap

%type <FieldRef> FieldRef

%%

// Entry points
viewExpr : ViewExpr EOF { $1 }
fieldExpr : FieldExpr EOF { $1 }
fieldType : FieldType EOF { $1 }
attributeMap : AttributeMap EOF { $1 }

// Expressions

ViewExpr:
    | MaybeArguments UnparenSelectExpr InsertEntityClause { { Arguments = $1; Select = $2; MainEntity = $3 } }

MaybeArguments:
    |                                            { Map.empty }
    | LEFT_BRACE ArgumentsList RIGHT_BRACE COLON { $2 }

ArgumentsList:
    |                       { Map.empty }
    | ArgumentsListNonEmpty { parseMap "Clashing argument names" $1 }

ArgumentsListNonEmpty:
    | ArgumentEntry                             { [ $1 ] }
    | ArgumentEntry COMMA ArgumentsListNonEmpty { $1 :: $3 }

ArgumentEntry:
    | ARGUMENT_ID Argument { (FunQLName $1, $2) }

Argument:
    | FieldType      { { ArgType = $1; Optional = false } }
    | FieldType NULL { { ArgType = $1; Optional = true } }

SelectVal:
    | SingleUnlimitedSelectExpr { { CTEs = None; Tree = SSelect $1; Extra = ObjectMap.empty } }
    | Values                    { { CTEs = None; Tree = $1; Extra = ObjectMap.empty } }
    | SubSelectExpr             { $1 }

WithExpr:
    | WITH WithBindings           { { Recursive = false; Exprs = Array.ofList $2; Extra = ObjectMap.empty } }
    | WITH RECURSIVE WithBindings { { Recursive = true; Exprs = Array.ofList $3; Extra = ObjectMap.empty } }

WithBinding:
    | Name WithBindingBody { ($1, $2) }

WithBindingBody:
    | AS SubSelectExpr               { { Fields = None; Expr = $2; Extra = ObjectMap.empty } }
    | ColumnAliases AS SubSelectExpr { { Fields = Some $1; Expr = $3; Extra = ObjectMap.empty } }

WithBindings:
    | WithBinding                    { [ $1 ] }
    | WithBinding COMMA              { [ $1 ] }
    | WithBinding COMMA WithBindings { $1 :: $3 }

// We don't allow select expressions with nested parentheses now because it's difficult to implement as LALR(1) for all our cases (or I'm missing something obvious).
UnparenSelectExpr:
    | WithExpr SelectTreeExpr { { CTEs = Some $1; Tree = $2; Extra = ObjectMap.empty } }
    | SelectTreeExpr          { { CTEs = None; Tree = $1; Extra = ObjectMap.empty } }

Values:
    | VALUES ValuesEntryList { SValues (List.toArray $2) }

SelectTreeExpr:
    | SingleSelectExpr                               { SSelect $1 }
    | Values                                         { $1 }
    | SelectVal SetOp SetOpExpr OrderLimitClause     { SSetOp { Operation = $2; AllowDuplicates = false; A = $1; B = $3; OrderLimit = $4 } }
    | SelectVal SetOp ALL SetOpExpr OrderLimitClause { SSetOp { Operation = $2; AllowDuplicates = true; A = $1; B = $4; OrderLimit = $5 } }

SubSelectExpr:
    | LEFT_PAREN UnparenSelectExpr RIGHT_PAREN { $2 }

SetOp:
    | UNION     { Union }
    | INTERSECT { Intersect }
    | EXCEPT    { Except }

SetOpExpr:
    | SelectVal                     { $1 }
    | SelectVal SetOp SetOpExpr     { { CTEs = None; Tree = SSetOp { Operation = $2; AllowDuplicates = false; A = $1; B = $3; OrderLimit = emptyOrderLimitClause }; Extra = ObjectMap.empty } }
    | SelectVal SetOp ALL SetOpExpr { { CTEs = None; Tree = SSetOp { Operation = $2; AllowDuplicates = true; A = $1; B = $4; OrderLimit = emptyOrderLimitClause }; Extra = ObjectMap.empty } }

SingleSelectExpr:
    | SingleUnlimitedSelectExpr OrderLimitClause { { $1 with OrderLimit = $2 } }

SingleUnlimitedSelectExpr:
    | SELECT QueryResults FromClause WhereClause GroupByClause {
        let (attributes, results) = splitResults $2
        { Attributes = attributes
          Results = results
          From = $3
          Where = $4
          GroupBy = $5
          OrderLimit = emptyOrderLimitClause
          Extra = ObjectMap.empty
        }
    }

OrderLimitClause:
    | OrderByClause LimitClause OffsetClause { { OrderBy = $1; Limit = $2; Offset = $3 } }

OrderByClause:
    |                      { [||] }
    | ORDER BY OrderByList { List.toArray $3 }

OrderByList:
    | OrderByExpr                   { [$1] }
    | OrderByExpr COMMA             { [$1] }
    | OrderByExpr COMMA OrderByList { $1 :: $3 }

OrderByExpr:
    | FieldExpr OrderByDirection { ($2, $1) }

OrderByDirection:
    |      { Asc }
    | ASC  { Asc }
    | DESC { Desc }

LimitClause:
    |                 { None }
    | LIMIT FieldExpr { Some $2 }

OffsetClause:
    |                  { None }
    | OFFSET FieldExpr { Some $2 }

FromClause:
    |               { None }
    | FROM FromExpr { Some $2 }

InsertEntityClause:
    |                           { None }
    | FOR INSERT INTO EntityRef { Some { Entity = $4 } }

QueryResults:
    |                                { [] }
    | NonEmptyQueryResults           { $1 }

NonEmptyQueryResults:
    | QueryResult                            { [$1] }
    | QueryResult COMMA                      { [$1] }
    | QueryResult COMMA NonEmptyQueryResults { $1 :: $3 }

QueryResult:
    | AT Name EQ FieldExpr       { AAttribute ($2, $4) }
    | Name DOT Name DOT MULTIPLY { AResult (QRAll (Some { Schema = Some $1; Name = $3; })) }
    | Name DOT MULTIPLY          { AResult (QRAll (Some { Schema = None; Name = $1; })) }
    | MULTIPLY                   { AResult (QRAll None) }
    | QueryColumnResult          { AResult (QRExpr $1) }

QueryColumnResult:
    | FieldExpr MaybeAttributeMap         { { Alias = None; Attributes = $2; Result = $1 } }
    | FieldExpr AS Name MaybeAttributeMap { { Alias = Some $3; Attributes = $4; Result = $1 } }

MaybeAttributeMap:
    |                                                   { Map.empty }
    | AttributeMap                                      { $1 }

AttributeMap:
    | AT_LEFT_BRACE RIGHT_BRACE                         { Map.empty }
    | AT_LEFT_BRACE AttributeValuesNonEmpty RIGHT_BRACE { parseMap "Clashing attribute names" $2 }

AttributeValuesNonEmpty:
    | Name EQ FieldExpr                               { [($1, $3)] }
    | Name EQ FieldExpr COMMA                         { [($1, $3)] }
    | Name EQ FieldExpr COMMA AttributeValuesNonEmpty { ($1, $3) :: $5 }

EntityAlias:
    | AS Name               { { Name = $2; Fields = None } }
    | AS Name ColumnAliases { { Name = $2; Fields = Some $3 } }

QuerySource:
    | SubSelectExpr EntityAlias       { FSubExpr ($2, $1) }
    | EntityRef                       { FEntity (None, $1) }
    | EntityRef AS Name               { FEntity (Some $3, $1) }
    | LEFT_PAREN FromExpr RIGHT_PAREN { $2 }

ColumnAliases:
    | LEFT_PAREN ColumnAliasesList RIGHT_PAREN { List.toArray $2 }

ColumnAliasesList:
    | Name                         { [$1] }
    | Name COMMA                   { [$1] }
    | Name COMMA ColumnAliasesList { $1 :: $3 }

ValuesEntryList:
    | ValuesEntry                       { [$1] }
    | ValuesEntry COMMA                 { [$1] }
    | ValuesEntry COMMA ValuesEntryList { $1 :: $3 }

ValuesEntry:
    | LEFT_PAREN ValueItemsList RIGHT_PAREN { List.toArray $2 }

ValueItemsList:
    | FieldExpr                      { [$1] }
    | FieldExpr COMMA                { [$1] }
    | FieldExpr COMMA ValueItemsList { $1 :: $3 }

JoinType:
    |       { Inner }
    | INNER { Inner }
    | OUTER { Outer }
    | LEFT  { Left  }
    | RIGHT { Right }

JoinChain:
    |                                                  { [] }
    | JoinType JOIN QuerySource ON FieldExpr JoinChain { ($1, $3, $5) :: $6 }

FromExpr:
    | QuerySource JoinChain { List.fold applyJoin $1 $2 }

EntityRef:
    | Name DOT Name { { Schema = Some $1; Name = $3; } }
    | Name          { { Schema = None; Name = $1; } }

ValueRef:
    | FieldRef           { VRColumn $1 }
    | ARGUMENT_ID        { VRPlaceholder (PLocal <| FunQLName $1) }
    | GLOBAL_ARGUMENT_ID { VRPlaceholder (PGlobal <| FunQLName $1) }

LinkedValueRef:
    | ValueRef LinkedFieldsList { { Ref = $1; Path = List.toArray $2 } }

LinkedFieldsList:
    |                                  { List.empty }
    | BOLD_ARROW Name LinkedFieldsList { $2 :: $3 }

FieldRef:
    | Name DOT Name DOT Name { { Entity = Some { Schema = Some $1; Name = $3 }; Name = $5 } }
    | Name DOT Name          { { Entity = Some { Schema = None; Name = $1 }; Name = $3 } }
    | Name                   { { Entity = None; Name = $1 } }

WhereClause:
    |                 { None }
    | WHERE FieldExpr { Some $2 }

GroupByClause:
    |                           { [||] }
    | GROUP BY NonEmptyExprList { $3 }

NonEmptyExprs:
    | FieldExpr { [ $1 ] }
    | FieldExpr COMMA { [ $1 ] }
    | FieldExpr COMMA NonEmptyExprs { $1 :: $3 }

NonEmptyExprList:
    | NonEmptyExprs { List.toArray $1 }

ParenedNonEmptyExprList:
    | LEFT_PAREN NonEmptyExprList RIGHT_PAREN { $2 }

ExprList:
    |                  { [||] }
    | NonEmptyExprList { $1 }

ParenedExprList:
    | LEFT_PAREN ExprList RIGHT_PAREN { $2 }


// See SQLParse for explanation on this.
AnyAllOp:
    | Any LEFT_PAREN FieldExpr RIGHT_PAREN { fun op a -> FEAny (a, op, $3) }
    | ALL LEFT_PAREN FieldExpr RIGHT_PAREN { fun op a -> FEAll (a, op, $3) }

Any:
    | ANY  { () }
    | SOME { () }

FieldExpr:
    | FieldExpr OR FieldExpr  { FEOr ($1, $3) }
    | FieldExpr AND FieldExpr { FEAnd ($1, $3) }
    | NOT FieldExpr           { FENot $2 }
    | FieldExprIs             { $1 }

FieldExprIs:
    | FieldExprEq IS NULL                          { FEIsNull $1 }
    | FieldExprEq IS NOT NULL                      { FEIsNotNull $1 }
    | FieldExprEq IS DISTINCT FROM FieldExprEq     { FEDistinct ($1, $5) }
    | FieldExprEq IS NOT DISTINCT FROM FieldExprEq { FENotDistinct ($1, $6) }
    | FieldExprEq                                  { $1 }

FieldExprEq:
    | FieldExprLike EQ FieldExprLikeOp2         { $3 BOEq $1 }
    | FieldExprLike LESS FieldExprLikeOp2       { $3 BOLess $1 }
    | FieldExprLike GREATER FieldExprLikeOp2    { $3 BOGreater $1 }
    | FieldExprLike NOT_EQ FieldExprLikeOp2     { $3 BONotEq $1 }
    | FieldExprLike LESS_EQ FieldExprLikeOp2    { $3 BOLessEq $1 }
    | FieldExprLike GREATER_EQ FieldExprLikeOp2 { $3 BOGreaterEq $1 }
    | FieldExprLike                             { $1 }

FieldExprLikeOp2:
    | FieldExprLike { fun op a -> FEBinaryOp (a, op, $1) }
    | AnyAllOp      { $1 }

FieldExprLike:
    | FieldExprMisc LIKE FieldExprMisc           { FEBinaryOp ($1, BOLike, $3) }
    | FieldExprMisc NOT LIKE FieldExprMisc       { FEBinaryOp ($1, BONotLike, $4) }
    | FieldExprMisc ILIKE FieldExprMisc          { FEBinaryOp ($1, BOILike, $3) }
    | FieldExprMisc NOT ILIKE FieldExprMisc      { FEBinaryOp ($1, BONotILike, $4) }
    | FieldExprMisc SIMILAR TO FieldExprMisc     { FESimilarTo ($1, $4) }
    | FieldExprMisc NOT SIMILAR TO FieldExprMisc { FENotSimilarTo ($1, $5) }
    | FieldExprMisc                              { $1 }

// Implemented in this way because there is a conflict between multi-paren-ed SelectExpr and FieldExpr with a SelectExpr inside.
FieldInSource:
    | SubSelectExpr           { ISSelect $1 }
    | ParenedNonEmptyExprList { extractInOneSource $1 }

FieldExprMisc:
    | FieldExprMisc LIKE_OP FieldExprMisc            { FEBinaryOp ($1, BOLike, $3) }
    | FieldExprMisc NOT_LIKE_OP FieldExprMisc        { FEBinaryOp ($1, BONotLike, $3) }
    | FieldExprMisc ILIKE_OP FieldExprMisc           { FEBinaryOp ($1, BOILike, $3) }
    | FieldExprMisc NOT_ILIKE_OP FieldExprMisc       { FEBinaryOp ($1, BONotILike, $3) }
    | FieldExprMisc MATCH_REGEX FieldExprMisc        { FEBinaryOp ($1, BOMatchRegex, $3) }
    | FieldExprMisc MATCH_REGEX_CI FieldExprMisc     { FEBinaryOp ($1, BOMatchRegexCI, $3) }
    | FieldExprMisc NOT_MATCH_REGEX FieldExprMisc    { FEBinaryOp ($1, BONotMatchRegex, $3) }
    | FieldExprMisc NOT_MATCH_REGEX_CI FieldExprMisc { FEBinaryOp ($1, BONotMatchRegexCI, $3) }
    | FieldExprMisc CONCAT FieldExprMisc             { FEBinaryOp ($1, BOConcat, $3) }
    | FieldExprMisc ARROW FieldExprMisc              { FEBinaryOp ($1, BOJsonArrow, $3) }
    | FieldExprMisc DOUBLE_ARROW FieldExprMisc       { FEBinaryOp ($1, BOJsonTextArrow, $3) }
    | FieldExprMisc PLUS FieldExprMisc               { FEBinaryOp ($1, BOPlus, $3) }
    | FieldExprMisc MINUS FieldExprMisc              { FEBinaryOp ($1, BOMinus, $3) }
    | FieldExprMisc MULTIPLY FieldExprMisc           { FEBinaryOp ($1, BOMultiply, $3) }
    | FieldExprMisc DIVIDE FieldExprMisc             { FEBinaryOp ($1, BODivide, $3) }

    // Now the same, but for ANY/ALL. I hate this.
    | FieldExprMisc LIKE_OP AnyAllOp                  { $3 BOLike $1 }
    | FieldExprMisc NOT_LIKE_OP AnyAllOp              { $3 BONotLike $1 }
    | FieldExprMisc ILIKE_OP AnyAllOp                 { $3 BOILike $1 }
    | FieldExprMisc NOT_ILIKE_OP AnyAllOp             { $3 BONotILike $1 }
    | FieldExprMisc MATCH_REGEX AnyAllOp              { $3 BOMatchRegex $1 }
    | FieldExprMisc MATCH_REGEX_CI AnyAllOp           { $3 BOMatchRegexCI $1 }
    | FieldExprMisc NOT_MATCH_REGEX AnyAllOp          { $3 BONotMatchRegex $1 }
    | FieldExprMisc NOT_MATCH_REGEX_CI AnyAllOp       { $3 BONotMatchRegexCI $1 }
    | FieldExprMisc CONCAT AnyAllOp                   { $3 BOConcat $1 }
    | FieldExprMisc ARROW AnyAllOp                    { $3 BOJsonArrow $1 }
    | FieldExprMisc DOUBLE_ARROW AnyAllOp             { $3 BOJsonTextArrow $1 }
    | FieldExprMisc PLUS AnyAllOp                     { $3 BOPlus $1 }
    | FieldExprMisc MINUS AnyAllOp                    { $3 BOMinus $1 }
    | FieldExprMisc MULTIPLY AnyAllOp                 { $3 BOMultiply $1 }
    | FieldExprMisc DIVIDE AnyAllOp                   { $3 BODivide $1 }

    | FieldExprMisc IN FieldInSource                  { inExpr FEIn FEInQuery $1 $3 }
    | FieldExprMisc NOT IN FieldInSource              { inExpr FENotIn FENotInQuery $1 $4 }
    | FieldExprMisc DOUBLE_COLON FieldExprType        { restrictCast $1 $3; FECast ($1, $3) }
    | CaseExpr                                        { $1 }
    | LinkedValueRef INHERITED FROM EntityRef         { FEInheritedFrom ($1, { Ref = $4; Extra = ObjectMap.empty }) }
    | LinkedValueRef OFTYPE EntityRef                 { FEOfType ($1, { Ref = $3; Extra = ObjectMap.empty }) }
    | LinkedValueRef                                  { FERef $1 }
    | Value                                           { FEValue $1 }
    | Name ParenedExprList                            { makeFunc $1 $2 }
    | Name LEFT_PAREN AggFuncArgs RIGHT_PAREN         { makeAggFunc $1 $3 }
    | JsonObject                                      { $1 }
    | JsonArray                                       { $1 }
    | SubSelectExpr                                   { FESubquery $1 }
    | LEFT_PAREN FieldExpr RIGHT_PAREN                { $2 }

AggFuncArgs:
    | ALL ExprList       { AEAll $2 }
    | DISTINCT FieldExpr { AEDistinct $2 }
    | MULTIPLY           { AEStar }

CaseExpr:
    | CASE CaseWhenList CaseElse END { FECase (List.toArray $2, $3) }

CaseWhenList:
    | WHEN FieldExpr THEN FieldExpr CaseWhenList { ($2, $4) :: $5 }
    | WHEN FieldExpr THEN FieldExpr              { [($2, $4)] }

CaseElse:
    |                { None }
    | ELSE FieldExpr { Some $2 }

IntArrayList:
    | INT                    { [ $1 ] }
    | INT COMMA IntArrayList { $1 :: $3 }

IntArrayNonEmpty:
    | IntArrayList { List.toArray $1 }

StringArrayList:
    | STRING                       { [ $1 ] }
    | STRING COMMA StringArrayList { $1 :: $3 }

StringArrayNonEmpty:
    | StringArrayList { List.toArray $1 }

BoolArrayList:
    | BOOL                     { [ $1 ] }
    | BOOL COMMA BoolArrayList { $1 :: $3 }

BoolArrayNonEmpty:
    | BoolArrayList { List.toArray $1 }

DecimalArrayList:
    | DECIMAL                        { [ $1 ] }
    | DECIMAL COMMA DecimalArrayList { $1 :: $3 }

DecimalArrayNonEmpty:
    | DecimalArrayList { List.toArray $1 }

UserViewRefArrayList:
    | UserViewRef                            { [ $1 ] }
    | UserViewRef COMMA UserViewRefArrayList { $1 :: $3 }

UserViewRefArrayNonEmpty:
    | UserViewRefArrayList { List.toArray $1 }

Value:
    | INT                                    { FInt $1 }
    | DECIMAL                                { FDecimal $1 }
    | PLUS INT                               { FInt $2 }
    | PLUS DECIMAL                           { FDecimal $2 }
    | MINUS INT                              { FInt (-$2) }
    | MINUS DECIMAL                          { FDecimal (-$2) }
    | STRING                                 { FString $1 }
    | BOOL                                   { FBool $1 }
    | UserViewRef                            { FUserViewRef $1 }
    | ARRAY LEFT_BRACKET Array RIGHT_BRACKET { $3 }
    | NULL                                   { FNull }

Array:
    |                          { FStringArray [||] }
    | StringArrayNonEmpty      { FStringArray $1 }
    | IntArrayNonEmpty         { FIntArray $1 }
    | BoolArrayNonEmpty        { FBoolArray $1 }
    | DecimalArrayNonEmpty     { FDecimalArray $1 }
    | UserViewRefArrayNonEmpty { FUserViewRefArray $1 }

UserViewRef:
    | AMPERSAND EntityRef { $2 }

JsonObject:
    | LEFT_BRACE JsonFields RIGHT_BRACE { coalesceJsonObject $2 }

JsonFields:
    |                            { [] }
    | JsonField                  { [$1] }
    | JsonField COMMA JsonFields { $1 :: $3 }

JsonField:
    | ID COLON FieldExpr { ($1, $3) }

JsonArray:
    | LEFT_BRACKET JsonItems RIGHT_BRACKET { coalesceJsonArray $2 }

JsonItems:
    |                   { [] }
    | NonEmptyJsonItems { $1 }

NonEmptyJsonItems:
    | FieldExpr                         { [$1] }
    | FieldExpr COMMA                   { [$1] }
    | FieldExpr COMMA NonEmptyJsonItems { $1 :: $3 }

ScalarType:
    | INT_TYPE      { SFTInt }
    | DECIMAL_TYPE  { SFTDecimal }
    | STRING_TYPE   { SFTString }
    | BOOL_TYPE     { SFTBool }
    | DATETIME_TYPE { SFTDateTime }
    | DATE_TYPE     { SFTDate }
    | INTERVAL_TYPE { SFTInterval }
    | JSON_TYPE     { SFTJson }
    | UVREF_TYPE    { SFTUserViewRef }
    | UUID_TYPE     { SFTUuid }

FieldExprType:
    | ScalarType                               { FETScalar $1 }
    | ARRAY LEFT_PAREN ScalarType RIGHT_PAREN  { FETArray $3 }

FieldType:
    | FieldExprType                                   { FTType $1 }
    | REFERENCE_TYPE LEFT_PAREN EntityRef RIGHT_PAREN { FTReference $3 }
    | ENUM_TYPE LEFT_PAREN EnumList RIGHT_PAREN       { FTEnum ($3 |> List.toSeq |> Set.ofSeqUnique) }

EnumList:
    | STRING                { [ $1 ] }
    | STRING COMMA EnumList { $1 :: $3 }

Name:
    | ID { FunQLName $1 }